<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2000000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Puzzle //
alpha = 0;
alpha_goal = 1;
alpha_flicker = 0;
timer_flicker = 5;
puzzle_intro = ""
puzzle_text = "I carry the weight, you can count on me,##I am better than John. What is my name?"
puzzle_answer = "diaper"
puzzle_length = 100;
selected_char = 0;
char_amount = 5;
answer_given = "";
timer_active = 10;
active = 0;

answer_char[0] = 0;
answer_char[1] = 0;
answer_char[2] = 0;
answer_char[3] = 0;
answer_char[4] = 0;
answer_char[5] = 0;

answer_locked[0] = false;
answer_locked[1] = false;
answer_locked[2] = false;
answer_locked[3] = false;
answer_locked[4] = false;
answer_locked[5] = false;

// With enough Piety, you can see some correct letters from the start //
piety = scr_stats_getBaseStat(o_hoopz, STAT_BASE_PIETY);
if piety &gt;= 20 then 
    {
    answer_char[1] = 9;
    answer_locked[1] = true;
    }
if piety &gt;= 30 then 
    {
    answer_char[5] = 18;
    answer_locked[5] = true;
    }
if piety &gt;= 40 then 
    {
    answer_char[2] = 1;
    answer_locked[2] = true;
    }

pool[0] = "-";
pool[1] = "a";
pool[2] = "b";
pool[3] = "c";
pool[4] = "d";
pool[5] = "e";
pool[6] = "f";
pool[7] = "g";
pool[8] = "h";
pool[9] = "i";
pool[10] = "j";
pool[11] = "k";
pool[12] = "l";
pool[13] = "m";
pool[14] = "n";
pool[15] = "o";
pool[16] = "p";
pool[17] = "q";
pool[18] = "r";
pool[19] = "s";
pool[20] = "t";
pool[21] = "u";
pool[22] = "v";
pool[23] = "w";
pool[24] = "x";
pool[25] = "y";
pool[26] = "z";
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Go back to the cabal monk //
with (o_mg_puzzleDwarf01) Cinema("run", script);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.event = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Pause /
if paused() exit;

// Block buttons for the first second, avoids problems this way //
if timer_active &gt; 0 then
    {
    timer_active -= dt();
    if timer_active &lt;= 0 then active = 1;
    }
    
// Inputs //
if active = 1 then
    {
    // Toggle letters //
    if scr_input_check_pressed(KEYID_LEFT, PLAYER1) then 
        {
        selected_char -= 1;
        if selected_char &lt; 0 then selected_char = char_amount;
        }    
    if scr_input_check_pressed(KEYID_RIGHT, PLAYER1) then 
        {
        selected_char += 1;
        if selected_char &gt; char_amount then selected_char = 0;
        }
    if scr_input_check_pressed(KEYID_DOWN, PLAYER1) then 
        {
        if answer_locked[selected_char] = false then 
            {
            answer_char[selected_char] -= 1;
            if answer_char[selected_char] &lt; 0 then answer_char[selected_char] = 26;
            }
        }    
    if scr_input_check_pressed(KEYID_UP, PLAYER1) then 
        {
        if answer_locked[selected_char] = false then 
            {
            answer_char[selected_char] += 1;
            if answer_char[selected_char] &gt; 26 then answer_char[selected_char] = 0;
            }
        }
        
    // See if it was correct //
    if scr_input_check_pressed(KEYID_ACTION, PLAYER1) or scr_input_check_pressed(KEYID_HOLSTER, PLAYER1) then 
        {
        // Compile answer //
        answer_given = string(pool[answer_char[0]]) + string(pool[answer_char[1]]) + string(pool[answer_char[2]]) + string(pool[answer_char[3]]) + string(pool[answer_char[4]]) + string(pool[answer_char[5]]);
        
        // Check if you win or lose //
        if answer_given = puzzle_answer then
            {
            // Solved //
            Quest("puzzleDwarf1", 1);
            }
        else
            {
            // Failed //
            Quest("puzzleDwarf1", 2);
            }
        
        // Remove this garbage //
        alpha_goal = 0;
        
        // Make inputs inactive //
        active = 2;
        alpha_flicker = 1;
        timer_flicker = 0;
        }
    }

// Alpha //
if alpha &lt; alpha_goal and alpha_goal &gt;= 1 then alpha += dt_sec() * 0.5;
else if alpha &gt; alpha_goal and alpha_goal &lt;= 0 then alpha -= dt_sec() * 0.25;

// Destruct //
if alpha_goal = 0 and alpha &lt;= 0 then instance_destroy();

// Flicker //
if timer_flicker &gt; 0 then
    {
    // Tick down //
    timer_flicker -= dt();
    
    // Event //
    if timer_flicker &lt;= 0 then 
        {
        timer_flicker = 2;
        if alpha_flicker = 1 then alpha_flicker = 0.25;
        else alpha_flicker = 1;
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw boxes //
draw_sprite_ext(s_mg_puzzleDwarf_interface, 0, view_xview + 192 - puzzle_length / 2, view_yview + 194, 1, 1, 0, c_white, alpha);
draw_sprite_ext(s_mg_puzzleDwarf_interface, 2, view_xview + 192 + puzzle_length / 2, view_yview + 194, 1, 1, 0, c_white, alpha);
for (i=0; i&lt;puzzle_length - 24; i+=1)
    {
    draw_sprite_ext(s_mg_puzzleDwarf_interface, 1, view_xview + 192 - puzzle_length / 2 + 24 + i, view_yview + 194, 1, 1, 0, c_white, alpha);
    }

// Draw puzzle text //
draw_set_color(c_white);
draw_set_alpha(alpha);
draw_set_halign(fa_center);
draw_set_font(global.fn_2);
draw_text(view_xview + 192, view_yview + 100, puzzle_text);

// Draw answer block //
draw_set_font(global.fn_1);
for (i=0; i&lt;6; i+=1;)
    {
    // Flicker selection //
    if selected_char = i then draw_set_alpha(alpha * alpha_flicker);
    else draw_set_alpha(alpha);
    
    // Is the selection locked or inactive or what? //
    if answer_locked[i] = true then draw_set_color(c_purple);
    else if active = 0 then draw_set_color(c_gray);
    else if active = 1 then draw_set_color(c_aqua);
    else if active = 2 then draw_set_color(c_red);
    
    // Draw the letters //
    draw_text(view_xview + 162 + i * 12, view_yview + 185, string_upper(pool[answer_char[i]]));
    }
    
// Reset halignment //
draw_set_halign(fa_left);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>15,46</point>
    <point>26,26</point>
  </PhysicsShapePoints>
</object>
