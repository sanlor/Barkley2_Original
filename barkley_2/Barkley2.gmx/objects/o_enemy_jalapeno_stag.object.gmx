<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_enemy_jalapeno_stag</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>o_enemygroup_cybergremlins</parentName>
  <maskName>mask_disk_40by32</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inherit from EnemyCombatActor
event_inherited();
bodSpr = s_enemy_jalapeno_stag;

// Sounds
deathSound = "junkbot_death";
damageSound = "junkbot_hurt";
soundAlert = "junkbot_alert";
soundChargeWarn = "junkbot_attack";
soundChargeRun = NULL;
soundChargeHit = NULL; //"junkbot_shot"; // does not work right now since hit by other object

// Variables
ailmentTotem_define(self.id, -5, 20, 0, 40);
combatActor_setRenderSurfSize(256);
scr_entity_setZHitbox(0, global.settingEnemyBigHeight);
scr_entity_setMovementCollisionShape_circle(32);
scr_entity_setShadowCircle(24);

// Animating vars
facDir = 0;
basSub = 0;
xsc = 1;
ysc = 1;
wlkSpd = 4; // 4 frames a second
wlkInd = 0;
shkSpd = 8;
shkInd = 0;
shkXin = 0;
shkYin = 0;

// Ailment totem coordinates //

// Enemy stats
scr_enemyDB_statsGet(enemyBuild);


//hook_hitfx = enemy_hitfx_cgremlins;

// Passive and active states
var guard = scr_AI_addPassiveState(scr_AI_passive_guard);

activeApproach = scr_AI_addActiveState(scr_AI_active_approach);
activeCircle = scr_AI_addActiveState(scr_AI_active_circle);
activeCircle[? "switchAddMaxDist"] = 80;
activeCircle[? "switchPriority"] = 10;
activeRetreat = scr_AI_addActiveState(scr_AI_active_retreat);
activeRetreat[? "switchPriority"] = 20;
activeRetreat[? "switchDisablePush"] = true;

// Movement
//scr_path_setMovementType(scr_path_movementType_8way);
scr_path_setMovementType(scr_path_movementType_standard_offset);
scr_path_setWalldist(12+random(10));

var movement = scr_AI_movement_init(scr_AI_movementType_standard);
movement[? "dirOffsetMax"] = 40;
activeApproach[? "walkScript"] = movement;
activeCircle[? "walkScript"] = movement;
activeRetreat[? "walkScript"] = movement;


ds_map_replace(guard, "sndAlertSound", soundAlert);


// Create and configure AI switch
var attack, action;
conf = scr_AI_setSwitch(scr_AI_switch_standard);

// Charge
attack = scr_AI_switch_standard("new_attack", conf);
action = scr_AI_addAction(scr_AI_action_charge_stag);
//AI_util_action_setDamage(action, 0, 0, 0, 0, 10, 100, STAGGER_HARDNESS_HARD);
attack[? "action"] = action; 
action[? "sndAttackWarn"] = soundChargeWarn; //attacking scream (desperate)
action[? "sndAttackStrike"] = soundChargeHit;
action[? "sndAttackRun"] = soundChargeRun;
action[? "windUp"] = 7; // Time spent before charging - 10 = 1 second
action[? "pantingTime"] = 20; // 25 = 2.5 seconds of panting
action[? "chargeDistance"] = 256; // Distance traveled per charge
//action[? "doRetreat"] = true; 
attack[? "distMax"] = 224; // Maximum distance he can be to attack
attack[? "cooldownTime"] = 30; //25; 
attack[? "cooldownTimeRnd"] = 15;
attack[? "rechargeTime"] = 5;
attack[? "rechargeTimeRnd"] = 2;

// Zauber - Bolt
anim = scr_AI_addAction(scr_AI_action_animation);
anim[? "attackName"] = "zauber_after";
anim[? "time"] = 20;

action = scr_AI_addAction(scr_AI_action_zauber);
action[? "chargeSpd"] = 0.1 / 3; // 3 seconds
action[? "zauber"] = zauber_cyber_bolt;
action[? "actionOnCast"] = anim;
action[? "targetSpd"] = 8;

attack = scr_AI_switch_standard("new_attack", conf);
attack[? "action"] = action;
attack[? "distMax"] = 240;
attack[? "cooldownTime"] = 30;
attack[? "cooldownTimeRnd"] = 15;
attack[? "rechargeTime"] = 8;
attack[? "rechargeTimeRnd"] = 0;

/////////////////// Gib map
gibAmt = 17;
gibSpr[0] = 0;   gibX[0] = -12;  gibY[0] = -100;  // top
gibSpr[1] = 1;   gibX[1] = -25;  gibY[1] = -94;  // horn0
gibSpr[2] = 2;   gibX[2] = 9;    gibY[2] = -99;  // horn1
gibSpr[3] = 3;   gibX[3] = 2;    gibY[3] = -76;  // forehead
gibSpr[4] = 4;   gibX[4] = -6;   gibY[4] = -48;  // cheek
gibSpr[5] = 5;   gibX[5] = 12;   gibY[5] = -52;  // nose
gibSpr[6] = 6;   gibX[6] = 10;   gibY[6] = -49;  // chunk0
gibSpr[7] = 6;   gibX[7] = 0;    gibY[7] = -24;  // chunk0
gibSpr[8] = 7;   gibX[8] = -11;  gibY[8] = -60;  // chunk1
gibSpr[9] = 7;   gibX[9] = 13;   gibY[9] = -29;  // chunk1
gibSpr[10] = 8;  gibX[10] = -16; gibY[10] = -19; // tail
gibSpr[11] = 9;  gibX[11] = -18; gibY[11] = -7;  // foot0a
gibSpr[12] = 9;  gibX[12] = -6;  gibY[12] = -9;  // foot0b
gibSpr[13] = 10; gibX[13] = 10;  gibY[13] = -7;  // foot1a
gibSpr[14] = 10; gibX[14] = 22;  gibY[14] = -15; // foot1a
// Extra
gibSpr[15] = 6;  gibX[15] = -10;  gibY[15] = -82;  // chunk0
gibSpr[16] = 7;  gibX[16] = 13;    gibY[16] = -63;  // chunk1
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if paused() exit;

if(a_attackName=="slash") {
    switch(a_attackState)
    {
        case "before": animStrike+=1; break;
        case "attack": animStrike =0; break;
        case "after": animStrike+=1; break;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Death FX
for (i = 0; i &lt; 3; i += 1)
{
    scr_fx_explosion_spawn_at(x - 10 + irandom(20), 
        y - 4 + irandom(8), z + random(32), 2 + irandom(2));
}

for (i = 0; i &lt; gibAmt; i += 1)
{
    gsc = xsc;
    // Reverse xscale if he is looking up
    if (basSub == 20) gsc = -xsc;
    gbx = x + (gibX[i] * gsc);
    gby = y + gibY[i];
    gbx += -2 + random(4);
    gby += -2 + random(4);
    obj = instance_create(gbx, y, o_gibs);
    obj.z = abs(gibY[i]);
    obj.timer = 20 + random(10);
    obj.sprite_index = s_enemy_jalapeno_stag_gibs;
    obj.image_index = gibSpr[i];
    obj.image_xscale = gsc;
    obj.image_angle = -10 + random(20);
    with (obj)
    {
        scr_entity_setDirSpd(random(360), 5 + random(2.5));
        shadow_visible = 0;
        //scr_entity_setShadowSprite(sprite_index, image_index, 0, 0);
    }
}

event_inherited();


exit;
var debris = irandom(6) + 3;
repeat (debris) {
    var gib = instance_create(x + 8 - random(16),y + 8 - random(16),o_gibs);
    gib.sprite_index = s_enemyDeath_parts;
    gib.image_index = irandom(sprite_get_number(s_enemyDeath_parts)-1);
    gib.z = z + 4 + random(32);
    gib.timer = 600;
    gib.move_z = 12 + random(16);
    gib.bloodburst = noone;
    gib.splatSound = "junkbot_death_partclink";
    gib.rot = 0;
    
    with gib {
        scr_entity_setDirSpd(random(360), 4 + random(30));
        scr_entity_setShadowSprite(sprite_index, image_index, 0, 0);
    }
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

var _dirdir = ((faceDir+360)mod 360) div 90;
var _odir = ((faceDir+360)mod 360);
facDir = faceDir mod 360;
wlkInd += wlkSpd * dt_sec();
shkInd += shkSpd * dt_sec();
if (a_attackName == "stagger")
{
    shkXin += dt_sec() * 5;
    shkYin += dt_sec() * 5;
    draw_sprite_ext(bodSpr, basSub + 19, dx + lengthdir_x(1, shkXin * 90), dy + lengthdir_y(1, shkYin * 125), xsc, ysc, 0, c_white, 1); 
}
else if (a_attackName == "charge")
{
    switch(a_attackState)
    {
        case "before":
            draw_sprite_ext(bodSpr, basSub + 0 + (shkInd mod 4), dx, dy, xsc, ysc, 0, c_white, 1);
            //draw_sprite_ext(bodSpr, basSub + 1 + ((shkInd * 2) mod 4), dx, dy, xsc, ysc, 0, c_white, 1); // + (shkInd mod 4)
            //draw_sprite_ext(bodSpr, basSub + 0 , dx, dy, xsc, ysc, 0, c_white, 1);
            break;
            
        case "approach":
            draw_sprite_ext(bodSpr, basSub + 2 + (shkInd*2 mod 4), dx, dy, xsc, ysc, 0, c_white, 1);
            break;
            
        case "attack":
            draw_sprite_ext(bodSpr, basSub + 6, dx, dy, xsc, ysc, 0, c_white, 1);
            break;
        
        case "after":
            draw_sprite_ext(bodSpr, basSub + 7 + (shkInd mod 8), dx, dy, xsc, ysc, 0, c_white, 1);
            break;
    }
}
else if (a_attackName == "zauber") // casting
{
    EffectZauber(bodSpr, basSub + 15 + (shkInd mod 4), dx, dy, xsc, ysc, c_aqua);
    draw_sprite_ext(bodSpr, basSub + 15 + (shkInd mod 4), dx, dy, xsc, ysc, 0, c_white, 1);
}
else if (a_attackName == "zauber_after") // after casting
{
    draw_sprite_ext(bodSpr, basSub + 7 + (shkInd mod 8), dx, dy, xsc, ysc, 0, c_white, 1);
}
else
{
    if (facDir &lt; 0 || facDir &gt; 180) 
    {
        basSub = 0;
        if (facDir &lt; 270) xsc = -1; else xsc = 1;
    }
    else 
    {
        basSub = 20;
        if (facDir &lt; 90) xsc = -1; else xsc = 1;
    }
    if a_walking then draw_sprite_ext(bodSpr, basSub + 2 + (wlkInd*2 mod 4), dx, dy, xsc, ysc, 0, c_white, 1);
    else draw_sprite_ext(bodSpr, 0, dx, dy, xsc, ysc, 0, c_white, 1);
}

combatActor_draw_post();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>14,18</point>
    <point>14,14</point>
  </PhysicsShapePoints>
</object>
