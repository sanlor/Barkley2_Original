<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_boss_crabcommander_body</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>o_enemyTemplate_crab</parentName>
  <maskName>s_boss_crabcommander_body</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Maximize code reuse
event_inherited();

// Recalibrate legs
LEGDIST_X = 125;
LEGDIST_Y = 125;
STEPDIST = 100;
STEPTIME = 18;
STEPPAUSE = 12;
STEPHEIGHT_LEGS = 90;
STEPHEIGHT_BODY = 3;
ZHEIGHT_BODY = 10;

leg_x[0] = x - LEGDIST_X;
leg_x[1] = x - LEGDIST_X;
leg_x[2] = x + LEGDIST_X;
leg_x[3] = x + LEGDIST_X;

leg_y[0] = y - LEGDIST_Y;
leg_y[1] = y + LEGDIST_Y;
leg_y[2] = y - LEGDIST_Y;
leg_y[3] = y + LEGDIST_Y;

leg_x_target[0] = leg_x[0];
leg_x_target[1] = leg_x[1];
leg_x_target[2] = leg_x[2];
leg_x_target[3] = leg_x[3];

leg_y_target[0] = leg_y[0];
leg_y_target[1] = leg_y[1];
leg_y_target[2] = leg_y[2];
leg_y_target[3] = leg_y[3];

// Create legs
leg_id[0] = instance_create(leg_x[0], leg_y[0], o_enemy_crabcommando_leg);
leg_id[1] = instance_create(leg_x[1], leg_y[1], o_enemy_crabcommando_leg);
leg_id[2] = instance_create(leg_x[2], leg_y[2], o_enemy_crabcommando_leg);
leg_id[3] = instance_create(leg_x[3], leg_y[3], o_enemy_crabcommando_leg);

z = ZHEIGHT_BODY;

leg_id[0].sprite_index = s_boss_crabcommander_leg_NW;
leg_id[1].sprite_index = s_boss_crabcommander_leg_SW;
leg_id[2].sprite_index = s_boss_crabcommander_leg_NE;
leg_id[3].sprite_index = s_boss_crabcommander_leg_SE;
leg_id[0].mask_index = s_boss_crabcommander_leg_NW;
leg_id[1].mask_index = s_boss_crabcommander_leg_SW;
leg_id[2].mask_index = s_boss_crabcommander_leg_NE;
leg_id[3].mask_index = s_boss_crabcommander_leg_SE;

// Define shadows
with leg_id[0] scr_entity_setShadowSprite(s_boss_crabcommander_leg_NW, 0, 0, 0);
with leg_id[1] scr_entity_setShadowSprite(s_boss_crabcommander_leg_SW, 0, 0, 0);
with leg_id[2] scr_entity_setShadowSprite(s_boss_crabcommander_leg_NE, 0, 0, 0);
with leg_id[3] scr_entity_setShadowSprite(s_boss_crabcommander_leg_SE, 0, 0, 0);
scr_entity_setShadowSprite(s_boss_crabcommander_body, 0, 0, 0);

/// --- CombatActor stuff
scr_actor_setActorPushType(ACTOR_COLLISIONPUSH_IMMOBILE);
scr_actor_setActorPushDist(30);
scr_path_setMovementType(scr_path_movementType_determineDirectionOnly);
scr_entity_setMovementCollisionShape_circle(100);
scr_entity_setCollisionType(COLLISION_NONE); // I am hardcoded to not impact with walls
scr_path_setLookaheadDist(100);
scr_path_setWalldist(200);
scr_entity_setZHitbox(0, global.settingEnemyBigHeight);

/// I have my own little fun Rigid
my_rigid = sat_make_shape_circle(x, y, 95);
rigid_set = false;
rigid_x = x;
rigid_y = y;

/// --- Set standard AI configurations
scr_enemyDB_statsGet(enemyBuild);

scr_stats_genEffectiveStats();
scr_stats_resetCurrentStats();

p_bulletOz = 4;


switch_conf = scr_AI_setSwitch(scr_AI_switch_standard);
scr_AI_addPassiveState(scr_AI_passive_none);
approach = scr_AI_addActiveState(scr_AI_active_croppedPathingApproach);
approach[? "stopAtDistance"] = 140;
approach[? "stopAtCroppedDistance"] = 80;
approach[? "cropLeft"] = x - 200;
approach[? "cropRight"] = x + 200;
approach[? "cropTop"] = y - 100;
approach[? "cropBottom"] = y + 100;

// Flamethrower
flamethrower_attack = scr_AI_switch_standard("new_attack", switch_conf);
flamethrower_action = scr_AI_addAction(scr_AI_action_crabCommando_flamethrower_circular);
flamethrower_attack[? "action"] = flamethrower_action; 

flamethrower_action[? "beforeTime"] = 13;
flamethrower_action[? "streamlength"] = 20;
flamethrower_action[? "streamwidth"] = 15;
flamethrower_action[? "repeats"] = 1;
AI_util_action_setDamage(flamethrower_action, 0,  0, 0, 0.33, 0, 0, STAGGER_HARDNESS_SOFT);

flamethrower_attack[? "distMax"] = 190;
flamethrower_attack[? "cooldownTime"] = 70; 
flamethrower_attack[? "cooldownTimeRnd"] = 70;
flamethrower_attack[? "cooldownStart"] = 250;
flamethrower_attack[? "rechargeTime"] = 30;
flamethrower_attack[? "rechargeTimeRnd"] = 0;
flamethrower_attack[? "coneAngleMax"] = 180;

// Photon Cannon
photoncannon_attack = scr_AI_switch_standard("new_attack", switch_conf);
photoncannon_action = scr_AI_addAction(scr_AI_action_crabotron_photoncannon);
photoncannon_attack[? "action"] = photoncannon_action; 

photoncannon_action[? "shots"] = 3;
photoncannon_action[? "afterTime"] = 7;
photoncannon_action[? "speed"] = 6;
photoncannon_action[? "speedRnd"] = 3;
photoncannon_action[? "zOffset"] = 150;
photoncannon_action[? "spread"] = 90;
photoncannon_action[? "allLegs"] = true;
photoncannon_action[? "scale"] = 1.8;
photoncannon_action[? "areaSpeed"] = 3;
AI_util_action_setDamage(photoncannon_action, 0, 0, 0, .5, 0, 10, STAGGER_HARDNESS_SOFT);

photoncannon_attack[? "distMax"] = 999;
photoncannon_attack[? "cooldownTime"] = 40; 
photoncannon_attack[? "cooldownTimeRnd"] = 20;
photoncannon_attack[? "cooldownStart"] = 70;
photoncannon_attack[? "rechargeTime"] = 5;
photoncannon_attack[? "rechargeTimeRnd"] = 2;
photoncannon_attack[? "coneAngleMax"] = 180;

// Photon Magnetizer
magnetize_attack = scr_AI_switch_standard("new_attack", switch_conf);
magnetize_action = scr_AI_addAction(scr_AI_action_crabCommando_magnetizePhotons);
magnetize_attack[? "action"] = magnetize_action; 

magnetize_action[? "speedBoost"] = 7;
magnetize_action[? "boostTime"] = 20;

magnetize_attack[? "distMax"] = 999;
magnetize_attack[? "cooldownTime"] = 320; 
magnetize_attack[? "cooldownTimeRnd"] = 50;
magnetize_attack[? "cooldownStart"] = 200;
magnetize_attack[? "rechargeTime"] = 10;
magnetize_attack[? "coneAngleMax"] = 180;

// Minion Vortex -- Ruined Drone
minionvortex1_attack = scr_AI_switch_standard("new_attack", switch_conf);
minionvortex1_action = scr_AI_addAction(scr_AI_action_crabCommando_spawnminion);
minionvortex1_attack[? "action"] = minionvortex1_action;

minionvortex1_action[? "decayTime"] = 25;

minionvortex1_attack[? "distMax"] = 9999;
minionvortex1_attack[? "cooldownTime"] = 250; 
minionvortex1_attack[? "cooldownTimeRnd"] = 100;
minionvortex1_attack[? "cooldownStart"] = 100;
minionvortex1_attack[? "rechargeTime"] = 0;
minionvortex1_attack[? "rechargeTimeRnd"] = 0;
minionvortex1_attack[? "coneAngleMax"] = 180;

// Minion Vortex -- Spidotron
minionvortex2_attack = scr_AI_switch_standard("new_attack", switch_conf);
minionvortex2_action = scr_AI_addAction(scr_AI_action_crabCommando_spawnminion);
minionvortex2_attack[? "action"] = minionvortex2_action;

minionvortex2_action[? "minionObject"] = o_enemy_smCrabotron;
minionvortex2_action[? "amount"] = 1;
minionvortex2_action[? "decayTime"] = 50;

minionvortex2_attack[? "distMax"] = 9999;
minionvortex2_attack[? "cooldownTime"] = 220; 
minionvortex2_attack[? "cooldownTimeRnd"] = 60;
minionvortex2_attack[? "cooldownStart"] = 180;
minionvortex2_attack[? "rechargeTime"] = 0;
minionvortex2_attack[? "rechargeTimeRnd"] = 0;
minionvortex2_attack[? "coneAngleMax"] = 180;


/// --- Always aggroed
scr_AI_aggro_configure(9999, 10000, 10000);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create hairball

/// Generate dustcloud

dustcloud = scr_dustcloud_create(s_boss_crabcommander_shrapnel);

repeat (30) {
    scr_dustcloud_addParticle(dustcloud, 10 + random(20), random(180), 4 + random(1), .1 + random(1), irandom(3), random(360));
}

repeat (110) {
    scr_dustcloud_addParticle(dustcloud, 30 + random(20), random(180), 3 + random(1), .1 + random(1), irandom(3), random(360));
}

repeat (110) {
    scr_dustcloud_addParticle(dustcloud, 50 + random(10), random(180), 2 + random(1), .1 + random(1), irandom(3), random(360));
}

repeat (120) {
    scr_dustcloud_addParticle(dustcloud, 60 + random(5), random(180), 1 + random(1), .1 + random(1), irandom(3), random(360));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (rigid_set) {
    scr_collisionSystem_remove_shape_semisolid(my_rigid);
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if paused() exit;

// Step hairball
scr_dustcloud_step(dustcloud);

// Remove my rigid when I move!
if (rigid_set == true and (abs(rigid_x - x) &gt;= 2 or abs(rigid_y - y) &gt;= 2)) {
    scr_collisionSystem_remove_shape_semisolid(my_rigid);
    rigid_set = false;
}

// Place down my rigid
if (rigid_set == false) {
    my_rigid[@ 2] = x;
    my_rigid[@ 3] = y;
    rigid_x = x;
    rigid_y = y;
    scr_collisionSystem_add_shape_semisolid(my_rigid);
    rigid_set = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// Draw me
if (AI_stateTopScript == scr_AI_action_crabCommando_magnetizePhotons) {
    scr_draw_spr(sprite_index, 1, dx, dy)
}
else {
    scr_draw_spr(sprite_index, 0, dx, dy)
}

// Draw hairball
scr_dustcloud_draw(dustcloud, dx, dy - 30);

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>74,56</point>
    <point>74,74</point>
  </PhysicsShapePoints>
</object>
