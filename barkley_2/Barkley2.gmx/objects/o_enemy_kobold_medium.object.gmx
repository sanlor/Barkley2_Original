<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_koboldMedium_head</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>o_enemygroup_kobold</parentName>
  <maskName>mask_disk_28by28</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////you get all the default variables from EnemyCombatActor
event_inherited();

// Enemy stats
scr_enemyDB_statsGet(enemyBuild);

// Enemy configurations
scr_entity_setZHitbox(0, global.settingEnemyBigHeight);
ailmentTotem_define(id, 0, 0, 0, 0);
scr_entity_setMovementCollisionShape_circle(12);
scr_entity_setCollisionType(COLLISION_ALL);

headType = irandom(12);
headType*=2;

deathSound = "kobold_death";
damageSound = "kobold_grunt";

hasHead = true;

hook_hitfx = enemy_hitfx_kobold_medium;

var conf, guard;
guard = scr_AI_addPassiveState(scr_AI_passive_guard);
guard[? "sndAlertSound"] = "kobold_alert"; //attacking scream (desperate)

activeApproach = scr_AI_addActiveState(scr_AI_active_approach);

// Movement
scr_path_setMovementType(scr_path_movementType_standard_offset);
scr_path_setWalldist(12+random(10));

var movement = scr_AI_movement_init(scr_AI_movementType_standard);
movement[? "dirOffsetMax"] = 40;
activeApproach[? "walkScript"] = movement;


// Create and configure AI switch
var attack, action;
conf = scr_AI_setSwitch(scr_AI_switch_standard);

// Slash
attack = scr_AI_switch_standard("new_attack", conf);
action = scr_AI_addAction(scr_AI_action_slash);
attack[? "action"] = action;

AI_util_action_setDamage(action, 2, .8, 0, 0, 10, 100, STAGGER_HARDNESS_SOFT);
action[? "sndAttackWarn"] = "kobold_attack";
action[? "sndAttackStrike"] = "kobold_swipe";
action[? "mask"] = mask_crescent_32_16;
action[? "range"] = 0;
action[? "atkStep"] = 8;
action[? "beforeTime"] = 4;
action[? "damageTime"] = 1;

attack[? "distMax"] = 50;
attack[? "cooldownTime"] = 8;
attack[? "cooldownTimeRnd"] = 5;
attack[? "rechargeTime"] = 8;
attack[? "rechargeTimeRnd"] = 0;


//Initiate Animation Entities
scr_entity_animation_new("body");
scr_entity_animation_new("head");
_body_offset=0;
_head_offset=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(hasHead)
{
    repeat(3)
    {
        ob = instance_create(x,y,o_gibs)
        with(ob)
        {
            scr_math_dirDistToVector(other.argument_attackId.move_dir-5+random(10), 10 + random(8));
            move_x = __vx;
            move_y = __vy;
        }
        ob.sprite_index = s_koboldBloodburst;
        ob.image_speed = 0.2;
        ob.image_angle = choose(0,90,180,270);
        ob.endOnAnimation = true;
        ob.gravity_z = 0;
        ob.z = argument_attackId.z;
        ob.move_z = argument_attackId.move_z;
        ob.splatSound = "kobold_splatter";
    }
    
    var curHp = scr_stats_getCurrentStat(id,STAT_CURRENT_HP);
    var maxHp = scr_stats_getEffectiveStat(id,STAT_EFFECTIVE_MAX_HP)
    if(curHp&lt;maxHp/2)
    {
        if(irandom(10)&lt;3)
        {
            hasHead = false;
            ob = instance_create(x,y,o_shootableGib);
            ob.sprite_index = s_koboldMedium_head;
            ob.image_index = headType;
            ob.image_speed = 0;
            ob.image_angle = 0;
            ob.splatSound = "kobold_splatter";
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var _obj;

repeat(4)
{
    scr_fx_simple_ext(x-5+random(10),y-5+random(19), z + random(10),
                      s_koboldBigBurst, 0.5 + random(0.5),
                      1, 1, choose(0,90,180,270), c_white, 1);
}

repeat(4)
{
    _obj = instance_create(x,y-4,o_shootableGib);
    _obj.sprite_index = s_koboldMed_gibs;
    _obj.bloodburst = s_koboldBigBurst;
    _obj.bounces = 5;
    _obj.image_index = irandom(_obj.image_number-1);
    _obj.move_z = 8 + random(8);
    _obj.gravity_z = 4;
    _obj.splatSound = "kobold_splatter";
}

instance_create(x+random(48)-24,y+random(48)-24,o_enemyAttack_oozeSplash);
instance_create(x+random(48)-24,y+random(48)-24,o_enemyAttack_oozeSplash);
instance_create(x,y,o_enemyAttack_oozeSplash);

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

var _col,pt2x,pt2y,pt3x,pt3y,_img,_hScale,_frm,_hoff,_hFrm,_showLArm,_showRArm,_rot,_headPos,_headShift,_SetWalkAnim;
_col = image_blend;

_frm = 0;
_img = 0;
_hScale = 1;
_hoff = 0;
_hFrm = 0;

_aFrmR = 0;
_aFrmL = 0;

_showLArm = true;
_showRArm = true;

_rot = 0;
_headPos = 20;
_headShift = 0;
_SetWalkAnim = false;
_img = s_cgremlin_small_gibs;

// Set hscale and body offset
_dirdir = ((faceDir+360)mod 360) div 90;
_odir = ((faceDir+360)mod 360);

switch(_dirdir)
{
    case 0: _hScale = -1;  _body_offset= 16; _head_offset=headType+1;  break;
    case 1: _hScale = 1;  _body_offset= 16; _head_offset=headType+1;  break;
    case 2: _hScale = -1; _body_offset= 0; _head_offset=headType;  break;
    case 3: _hScale = 1; _body_offset= 0; _head_offset=headType;  break;
}

// Set head sprite
scr_entity_animation_setSpeed("head", 0);
scr_entity_animation_setRange("head", _head_offset, 1);

// Set body sprite
if(a_attackName == "stagger")
{
    scr_entity_animation_setSpeed("body", 0);
    scr_entity_animation_setRange("body", _body_offset, 1);
    _hFrm = headType;
}
else
{
    if(a_walking)
    {
        scr_entity_animation_setSpeed("body", move_dist/4);
        scr_entity_animation_setRange("body", _body_offset, 12);
        
        switch(floor(scr_entity_animation_getFrame("body"))) ///adjust the head
        {
            case 0:      _rot = -6; _headPos = 0; break;
            case 1:      _rot = -12; _headPos = -1; break;
            case 2:      _rot = -8; _headPos = 0; break;
            case 3:      _rot = -8; _headPos = 0; break;
            case 4:      _rot = -2; _headPos = 1; break;
            case 5:      _rot = 0; _headPos = 1; break;
            case 6:      _rot = 0; _headPos = 0; break;
            case 7:      _rot = 8; _headPos = -1; break;
            case 8:      _rot = 4; _headPos = 0; break;
            case 9:      _rot = 2; _headPos = 0; break;
            case 10:     _rot = 2; _headPos = 1; break;
            case 11:     _rot = 0; _headPos = 1; break;
        }
        _headPos+=20;
    }
    else
    {
        _frm = 24;
        _hFrm = headType;
    }
}

switch(a_attackName)
{
    case "slash":
        switch(a_attackState)
        {
            case "before":
                scr_entity_animation_setSpeed("body", 0);
                var __frm = min(2,floor(a_attackAnim))
                scr_entity_animation_setRange("body", _body_offset + 12 + __frm, 1);
                switch(__frm) ///adjust the head
                {
                    case 0:      _rot = 40;     _headPos = -1;   _headShift = -8; break;
                    case 1:      _rot = 50;    _headPos = -4;  _headShift = -10; break;
                    case 2:      _rot = 60;     _headPos = -5;   _headShift = -11; break;
                }
                _headPos+=20;
                break;
                
            case "damage":
                scr_entity_animation_setSpeed("body", 0);
                scr_entity_animation_setRange("body", _body_offset + 15, 1);
                _rot = 70; _headPos = -8;_headShift = -8;
                _headPos+=20;
                break;
            
            case "after":
                scr_entity_animation_setSpeed("body", 0);
                var __frm = min(2,3-floor(a_attackAnim))
                scr_entity_animation_setRange("body", _body_offset + 12 +__frm, 1);
                switch(__frm) ///adjust the head
                {
                    case 0:      _rot = 40;     _headPos = -1;   _headShift = -8; break;
                    case 1:      _rot = 50;     _headPos = -4;  _headShift = -10; break;
                    case 2:      _rot = 60;     _headPos = -5;   _headShift = -11; break;
                }
                _headPos+=20;
                break;
        }
        
        if(_body_offset==16)
        {
            _headPos-=14;
        }
        break;
    
}

if(_body_offset==16)
{
    _rot = _rot * (0-_hScale);
    _headShift = _headShift*(0-_hScale);
}
else
{
    _rot = _rot * _hScale;
    _headShift = _headShift*_hScale;
}

draw_set_alpha(1);

draw_sprite_ext(s_koboldMedium_body,scr_entity_animation_getImage("body"),dx,dy,_hScale,1,0,_col,1);

if(hasHead)
{
    draw_sprite_ext(s_koboldMedium_head,scr_entity_animation_getImage("head"),dx+_headShift,dy-_headPos,_hScale,1,_rot,_col,1);
}

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>24,15</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
