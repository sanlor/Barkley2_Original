<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_junkbot_head_frankie</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>EnemyCombatActor</parentName>
  <maskName>mask_disk_24by24</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup
event_inherited();

scr_entity_setZHitbox(0, global.settingEnemyBigHeight);
ailmentTotem_define(id, 0, 0, 0, 0);
scr_enemyDB_statsGet(enemyBuild);

// Init vars
headDir = 0;
_beam = NULL;
_beam2 = NULL;

deathSound = "junkbot_death";
damageSound = "junkbot_hurt";

// --- Define parts ---
// Each part is an object
parts = ds_map_create();
parts[? "larm"] = noone;
parts[? "rarm"] = noone;
parts[? "head"] = noone;
parts[? "legs"] = noone;
parts[? "body"] = noone;

// Define actions per part. Each action is NULL or a map
actions = ds_map_create();
actions[? "leftarm"] = NULL;
actions[? "rightarm"] = NULL;
actions[? "legs"] = NULL;
actions[? "head"] = NULL;

// --- AI Configuration ---
scr_AI_aggro_configure(110, 300, 700);

// Create and configure AI switch
var attack, action;
conf = scr_AI_setSwitch(scr_AI_switch_standard);

// Passive and active states
passiveRoaming = scr_AI_addPassiveState(scr_AI_passive_junkbotRoam);
passiveRoaming[? "sndAlertSound"] = "junkbot_alert";

activeApproach = scr_AI_addActiveState(scr_AI_active_approach);
activeApproach[? "stopAtDistance"] = 30;
activeApproach[? "turnSpd"] = 5;

activeHangback = scr_AI_addActiveState(scr_AI_active_hangback);
activeHangback[? "switchPriority"] = 10;
activeHangback[? "switchAddMaxDist"] = 100;
activeHangback[? "switchRemoveMaxDist"] = 130;
activeHangback[? "quantizeDirections"] = 8;


// Action: Pick up nearby part
attack = scr_AI_switch_standard("new_attack", conf);
var action = scr_AI_addAction(scr_AI_action_junkbot_pickuppart);
attack[? "action"] = action; 
passiveRoaming[? "pickupAction"] = action;

attack[? "coneAngleMax"] = 180;
attack[? "distMax"] = 120;
attack[? "cooldownTime"] = 0;
attack[? "cooldownTimeRnd"] = 0;
attack[? "rechargeTime"] = 5;
attack[? "rechargeTimeRnd"] = 0;
attack[? "predicate"] = predicate_AI_junkbot_nearbyPart;


// Start with a pair of legs
var legObj = choose(o_enemy_junkbot_part_leg_threads,
                    o_enemy_junkbot_part_leg_tires,
                    o_enemy_junkbot_part_leg_washingmachine);
scr_enemy_junkbot_attachPart(legObj, "legs");

// Start with a body
var bodyObj = choose(o_enemy_junkbot_part_body_regular,
                     o_enemy_junkbot_part_body_thin,
                     o_enemy_junkbot_part_body_armoured,
                     o_enemy_junkbot_part_body_barrel,
                     o_enemy_junkbot_part_body_engine,
                     o_enemy_junkbot_part_body_pipes,
                     o_enemy_junkbot_part_body_tv);
scr_enemy_junkbot_attachPart(bodyObj, "body");

// Start with a head 70% of the time
if (random(1) &lt; .7) {
    var headObj = choose(o_enemy_junkbot_part_head_can,
                         o_enemy_junkbot_part_head_dualLazer,
                         o_enemy_junkbot_part_head_frankie,
                         o_enemy_junkbot_part_head_gasmask,
                         o_enemy_junkbot_part_head_propeller,
                         o_enemy_junkbot_part_head_scifi,
                         o_enemy_junkbot_part_head_singleLazer,
                         o_enemy_junkbot_part_head_walle);
    scr_enemy_junkbot_attachPart(headObj, "head");
}

// Start with a left or right arm
if (random(1) &lt; .5) {
    var larmObj = choose(o_enemy_junkbot_part_larm_chainsaw,
                         o_enemy_junkbot_part_larm_flamethrower,
                         o_enemy_junkbot_part_larm_missilepod,
                         o_enemy_junkbot_part_larm_polluter,
                         o_enemy_junkbot_part_larm_shield);
    scr_enemy_junkbot_attachPart(larmObj, "larm");
} else {
    var rarmObj = choose(o_enemy_junkbot_part_rarm_chainsaw,
                         o_enemy_junkbot_part_rarm_flamethrower,
                         o_enemy_junkbot_part_rarm_missilepod,
                         o_enemy_junkbot_part_rarm_polluter,
                         o_enemy_junkbot_part_rarm_shield);
    scr_enemy_junkbot_attachPart(rarmObj, "rarm");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Destroy all my parts
var key = ds_map_find_first(parts);
for (var i = 0; i &lt; ds_map_size(parts); i++) {
    var part = parts[? key];
    if (part != NULL and instance_exists(part)) {
        with (part) {instance_destroy()}
    }
    key = ds_map_find_next(parts,key);
}

if (scr_stats_getCurrentStat(id, STAT_CURRENT_HP) &lt;= 0) {
    // Death FX
    scr_fx_explosion_spawn_at(x, y, z, 7);
    
    var debris = irandom(10) + 30;
    repeat (debris) {
        var gib = instance_create(x + 8 - random(16),y + 8 - random(16),o_gibs);
        gib.sprite_index = s_enemyDeath_parts;
        gib.image_index = irandom(sprite_get_number(s_enemyDeath_parts)-1);
        gib.z = z + 4 + random(32);
        gib.timer = 600;
        gib.move_z = 12 + random(16);
        gib.bloodburst = noone;
        gib.splatSound = "junkbot_death_partclink";
        gib.rot = 0;
        
        with gib {
            scr_entity_setDirSpd(random(360), 4 + random(24));
            scr_entity_setShadowSprite(sprite_index, image_index, 0, 0);
        }
    }
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if paused() exit;


// Relocate legs
var legs = parts[? "legs"];
var heightLegs = legs.height;
legs.x = x;
legs.y = y;
legs.z = z;
legs.move_z = 0;

// Relocate body
var body = parts[? "body"];
var heightBody = body.height;
body.x = x;
body.y = y;
body.z = z + heightLegs;
body.move_z = 0;

// Relocate head
var head = parts[? "head"];
if (head != noone and instance_exists(head)) {
    head.x = x;
    head.y = y;
    head.z = z + heightLegs + heightBody;
    head.move_z = 0;
}

// Relocate arms
var octantLook = modp(headDir+22.5, 360) div 45;

var larm = parts[? "larm"];
if (larm != noone and instance_exists(larm)) {
    var dist = larm.attach_width + body.attach_width;
    var dir = octantLook*45 + 90;
    larm.x = x + lengthdir_x(dist, dir);
    larm.y = y + lengthdir_y(dist, dir);
    larm.z = z + heightLegs + body.attach_height - larm.attach_height;
    var larmz = z;
    larm.move_z = 0;
}

var rarm = parts[? "rarm"];
if (rarm != noone and instance_exists(rarm)) {
    var dist = rarm.attach_width + body.attach_width;
    var dir = octantLook*45 - 90;
    rarm.x = x + lengthdir_x(dist, dir);
    rarm.y = y + lengthdir_y(dist, dir);
    rarm.z = z + heightLegs + body.attach_height - rarm.attach_height;
    rarm.move_z = 0;
}

// Disable hangback state if has melee part
if     ((larm != noone and instance_exists(larm) and larm.object_index = o_enemy_junkbot_part_larm_chainsaw) or
        (rarm != noone and instance_exists(rarm) and rarm.object_index = o_enemy_junkbot_part_rarm_chainsaw)) {
    activeHangback[? "switchDisablePush"] = true; // Disable entering hangback   
} else {
    activeHangback[? "switchDisablePush"] = false;
}

// If picking up part, highlight it
if (AI_stateTopScript == scr_AI_action_junkbot_pickuppart) {
    var part = AI_stateTop[? "part"];
    if (part &gt;= 0 and instance_exists(part)) {
        part.drawHighlight = true;
    }
}

// Define my hitbox height
scr_entity_setZHitbox(0, heightLegs + heightBody);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw lazer beams, "this is where the magic begins"

var legs = parts[? "legs"];
var legHeight = legs.height;
var body = parts[? "body"];
var bodyHeight = body.height;

var _bx = dx + (cos(degtorad(headDir))*8);
var _by = dy - (sin(degtorad(headDir))*8) - legHeight - bodyHeight - 6;

if (_beam &gt; 0 and instance_exists(_beam)) {
    draw_line_color(_bx,_by,_beam.x,_beam.y,make_color_rgb(255,85,200),make_color_rgb(255,85,200));
    draw_primitive_begin(pr_trianglelist);
    draw_vertex_color(_bx,_by,make_color_rgb(247,19,179),0.7);
    draw_vertex_color(_beam.x,_beam.y,c_red,0.9);
    draw_vertex_color(lerp(_beam.x,_beam.ox,1-(_beam.count*0.1)), lerp(_beam.y,_beam.oy,1-(_beam.count*0.1)),c_red,0.1);
    draw_primitive_end();
}  

if (_beam2 &gt; 0 and instance_exists(_beam2)) {
    draw_line_color(_bx,_by,_beam2.x,_beam2.y,make_color_rgb(255,85,200),make_color_rgb(255,85,200));
    draw_primitive_begin(pr_trianglelist);
    draw_vertex_color(_bx,_by,make_color_rgb(247,19,179),0.7);
    draw_vertex_color(_beam2.x,_beam2.y,c_red,0.9);
    draw_vertex_color(lerp(_beam2.x,_beam2.ox,1-(_beam2.count*0.1)), lerp(_beam2.y,_beam2.oy,1-(_beam2.count*0.1)),c_red,0.1);
    draw_primitive_end();
}  
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// -- Get quadrant enemy is facing towards
var octantLook = modp(headDir+22.5, 360) div 45;


// Get which parts to draw
var body = parts[? "body"];
var legs = parts[? "legs"];

var drawHead = false;
var head = parts[? "head"];
if (head != noone and instance_exists(head)) {
    drawHead = true;
}

var drawLArm = false;
var forceLArmFront = false;
var larm = parts[? "larm"];
if (larm != noone and instance_exists(larm)) {
    drawLArm = true;
    if (larm.object_index == o_enemy_junkbot_part_larm_shield and octantLook == 7) {
        forceLArmFront = true;
    }
}

var drawRArm = false;
var forceRArmFront = false;
var rarm = parts[? "rarm"];
if (rarm != noone and instance_exists(rarm)) {
    drawRArm = true;
    if (rarm.object_index == o_enemy_junkbot_part_rarm_shield and octantLook == 5) {
        forceRArmFront = true;
    }
}

// Check if picking up a part
var drawPart = false;
var part;
if (AI_stateTopScript == scr_AI_action_junkbot_pickuppart) {
    part = AI_stateTop[? "part"];
    if (part &gt;= 0 and instance_exists(part)) {
        drawPart = true;
    }
}


// Draw everything
// NOTE: Draw order depending on direction facing is important here.

if (octantLook = 0 or octantLook = 1 or octantLook = 7) {
    if (!forceLArmFront) { if (drawLArm) with larm event_user(0); }
    with legs event_user(0);
    with body event_user(0);
    if (drawHead) with head event_user(0);
    if (forceLArmFront) { if (drawLArm) with larm event_user(0); }
    if (drawRArm) with rarm event_user(0);
}
else if (octantLook = 2) {
    if (drawLArm) with larm event_user(0);
    if (drawRArm) with rarm event_user(0);
    with legs event_user(0);
    with body event_user(0);
    if (drawHead) with head event_user(0);
}
else if (octantLook = 3 or octantLook = 4 or octantLook = 5) {
    if (!forceRArmFront) { if (drawRArm) with rarm event_user(0); }
    with legs event_user(0);
    with body event_user(0);
    if (drawHead) with head event_user(0);
    if (forceRArmFront) { if (drawRArm) with rarm event_user(0); }
    if (drawLArm) with larm event_user(0);
}
else if (octantLook = 6) {
    with legs event_user(0);
    with body event_user(0);
    if (drawHead) with head event_user(0);
    if (drawLArm) with larm event_user(0);
    if (drawRArm) with rarm event_user(0);
}

event_user(15);

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
