<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ww = 96;            //Width of the "ring" effect
radius = 0;         //Size check variable
r_max = 320;        //Maximum radius of the effect
spd = 6;            //Expansion speed
segments = 32;      //Ring "segments" to be drawn

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if paused() exit;

// Increase radius
if radius &lt; r_max radius += spd*dt() else instance_destroy();

//Alpha modifier
var a = 1 / (r_max / spd);
image_alpha -= a * dt();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Copy surface from screen buffer
surf = surface_create(SCREEN_WIDTH, SCREEN_HEIGHT);
surface_copy(surf, 0, 0, scr_screenSurface_getBufferNoHud());
tex = surface_get_texture(surf);
srf_w = surface_get_width(surf);
srf_h = surface_get_height(surf);
tex_w = texture_get_width(tex);
tex_h = texture_get_height(tex);

// Begin Draw
var o = (-radius + r_max) / 5;      //Distortion offset
var sx = tex_w / srf_w;             //Texture x coord ratio
var sy = tex_h / srf_h;             //texture y coord ratio
var d = 360/segments;
var scr_wmid = SCREEN_WIDTH / 2;
var scr_hmid = SCREEN_HEIGHT / 2;
draw_set_colour(c_white);

//Draw the inner part of the ring
var xx, yy, tx, ty;
draw_primitive_begin_texture(pr_trianglestrip, tex);
var c = 0;
repeat(segments+1) // NOTE FOR LAZ: Put +1 here or it will not render the last segment of the trianglestrip
    {
    xx = x + lengthdir_x(radius, c * d);
    yy = y + lengthdir_y(radius, c * d);
    tx = 0.5 + sx * (lengthdir_x(radius, c * d) + lengthdir_x(o, c * d));  // NOTE FOR LAZ: Middle of screen should equal middle coordinate of texture (0.5),
    ty = 0.5 + sy * (lengthdir_y(radius, c * d) + lengthdir_y(o, c * d));  //               so here we start out from 0.5 and ripple out with radius....
    tx += sx * ((x-view_xview)-scr_wmid); // ... and here, we move texture coordinate based on the ripple effect position relative to the middle of the screen.
    ty += sy * ((y-view_yview)-scr_hmid);
    draw_vertex_texture_color(xx, yy, tx, ty, c_white, image_alpha);
    xx = x + lengthdir_x(radius - ww, c * d);
    yy = y + lengthdir_y(radius - ww, c * d);
    tx = 0.5 + sx * lengthdir_x(radius-ww, c * d);
    ty = 0.5 + sy * lengthdir_y(radius-ww, c * d);
    tx += sx * ((x-view_xview)-scr_wmid);
    ty += sy * ((y-view_yview)-scr_hmid);
    draw_vertex_texture_color(xx, yy, tx, ty, c_white, 0);
    
    c += 1;
    }
draw_primitive_end();

//Draw the outer part of the ring
draw_primitive_begin_texture(pr_trianglestrip, tex);
c = 0
repeat(segments+1)
    {
    xx = x + lengthdir_x(radius + ww, c * d);
    yy = y + lengthdir_y(radius + ww, c * d);
    tx = 0.5 + sx * lengthdir_x(radius+ww, c * d);
    ty = 0.5 + sy * lengthdir_y(radius+ww, c * d);
    tx += sx * ((x-view_xview)-scr_wmid);
    ty += sy * ((y-view_yview)-scr_hmid);
    draw_vertex_texture_color(xx, yy, tx, ty, c_white, 0);
    xx = x + lengthdir_x(radius, c * d);
    yy = y + lengthdir_y(radius, c * d);
    tx = 0.5 + sx * (lengthdir_x(radius, c * d) + lengthdir_x(o, c * d));
    ty = 0.5 + sy * (lengthdir_y(radius, c * d) + lengthdir_y(o, c * d));
    tx += sx * ((x-view_xview)-scr_wmid);
    ty += sy * ((y-view_yview)-scr_hmid);
    draw_vertex_texture_color(xx, yy, tx, ty, c_white, image_alpha);
    
    c += 1;
    }
draw_primitive_end();


// Cleanup
surface_free(surf);
    

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
