<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_minotaur01</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>InteractiveActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///The Minotaur Bull connected to the Stock Market
event_inherited();

//Animation States
scr_entity_animation_define("bullMarket", s_minotaur01, 0, 1, 0);
scr_entity_animation_define("bearMarket", s_minotaur01, 1, 1, 0);

//Set the bull to be charging unless Market State is 1 ie. "crashed"
if Quest("marketState") == 1 {
    scr_entity_animation_set(o_minotaur01, "bearMarket");
}
else scr_entity_animation_set(o_minotaur01, "bullMarket");

attacking = 0;
targetX = 0;
targetY = 0;
attackRange = 100;
attackTime = 1;
chargeRange = 30;
chargePower = 0;
hoopzInRange = 0;
attackTimer = attackTime;

//Animation Data
offsetTime = 0;
segmentOffsetsX[0] = 0;
segmentOffsetsY[0] = 0;
offsetDuration = 30;
offset = offsetDuration;
segmentDistance = 15;
lastSegmentCount = 0;
flashing = false;
/*
script = "
CHOICE | Set the randomized respawn upon death?
REPLY  | SET_YAY | Yes. Randomized Respawn.
REPLY  | SET_KAY | No, I want to go to AFTER the Randomized Respawn.
REPLY  | SET_NAY | No, I want to go to BEFORE the Randomized Respawn.

SET_YAY
DIALOG | Dorkus | You will now respawn in a random location when defeated, just as inteded during the first journey into Cuchu's Lair as ordered by Wiglaf.
QUEST  | cuchuRespawn = 1

REPLY  | SET_KAY
DIALOG | Dorkus | You are now basically beyond the random respawn segment of the game.
QUEST  | cuchuRespawn = 2

SET_NAY
DIALOG | Dorkus | You will not be respawned into a random location now. Basically the situation right now is how it would be before Wiglaf's Cuchu's Lair mission.
QUEST  | cuchuRespawn = 0
";
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Attack hoopz
if(instance_exists(o_hoopz)){
    var distance = abs(o_hoopz.x - x);
    chargePower = 1 - max((max(distance, attackRange)-attackRange)/chargeRange, 1);

    if(distance &lt; attackRange){
        hoopzInRange = 1;
        attacking = 1;
    } else {
        hoopzInRange = 0;
    }
    
    if(Quest("marketState") == 1 &amp;&amp; !hoopzInRange){
            //Target the statue
    } else {
            targetX = o_hoopz.x;
            targetY = o_hoopz.y;
    }

    if(attacking){        
        if(!paused())  attackTimer -= dt();
        if(attackTimer &lt; 0){
            attackTimer = attackTime;
            var n = instance_create(targetX, targetY, o_enemyAttack_melee_static);
            n.lifetime = 0.1;
            n.mask_index = mask_disk_64by64;
            ds_list_clear(n.target_list);
            scr_stats_setAttackStat(n, STAT_ATTACK_KNOCKBACK, 0);
            var dmg = 999;
            scr_stats_setAttackStat(n, STAT_ATTACK_DMG_COSMIC, max( max(1-(offsetStrength*5),0)*dmg, 10));
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>startX = x-32;
startY = y-60;
endX = targetX;
endY = targetY-10;

if(flashing) {
  draw_circle_colour(x-28, y-35, chargePower*5*random_range(1,2), c_red, c_red, 0);
  draw_circle_colour(x-28, y-35, chargePower*2*random_range(1,2), c_white, c_white, 0);
}
flashing = !flashing;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>startX = x-32;
startY = y-64;
endX = targetX;
endY = targetY-10;

distance = point_distance(startX, startY, endX, endY);
angle = point_direction(startX, startY, endX, endX);
segmentCount = round(distance/segmentDistance);

if(segmentCount &gt; array_length_1d(segmentOffsetsX)){
    for (var i = array_length_1d(segmentOffsetsX); i &lt; segmentCount; i++;){
        segmentOffsetsX[i] = random_range(-1,1);
        segmentOffsetsY[i] = random_range(-1,1);
    }   
}

segmentsX[0] = startX;
segmentsY[0] = startY;
segmentsX[segmentCount] = endX;
segmentsY[segmentCount] = endY;

normalX = (endX-startX)/distance;
normalY = (endY-startY)/distance;
segmentLength = distance/segmentCount;

if(!paused()) offsetTime -= dt();

if(offsetTime &lt; 0){
    for (var i = 0; i &lt; segmentCount; i++;){
        segmentOffsetsX[i] = random_range(-1,1);
        segmentOffsetsY[i] = random_range(-1,1);
    }   
    offsetTime = offsetDuration;
}

offsetStrength = 1-(offsetTime/offsetDuration);

for (var i = 1; i &lt; segmentCount; i++;){
    segmentsX[i] = startX +
        (segmentOffsetsX[i] * offsetStrength * offset) +
        //random_range(-2,2)*(offsetStrength)+
        (normalX*segmentLength*i);
    segmentsY[i] = startY + 
        (segmentOffsetsY[i] * offsetStrength * offset) +
        random_range(-2,2)*(offsetStrength)+
        ((max(segmentOffsetsY[i],0)*15)*offsetStrength*(1-abs((segmentCount/2)-i)/(segmentCount/2)))+
        (normalY*segmentLength*i);
}

if(flashing) {
  var size = max( max(1-(offsetStrength*3),0)*15, 1);
  for (var i = 0; i &lt; segmentCount; i++;){
      draw_line_width_colour(
          segmentsX[i],segmentsY[i],segmentsX[i+1],segmentsY[i+1], 
          size, 
          c_red, c_red);
  }
  draw_circle_colour(startX, startY, size*random_range(0.9,1.1), c_red, c_red, false);
  draw_circle_colour(endX, endY, size*random_range(0.9,1.1), c_red, c_red, false);

  for (var i = 0; i &lt; segmentCount; i++;){
      draw_line_width_colour(
          segmentsX[i],segmentsY[i],segmentsX[i+1],segmentsY[i+1], 
          max( max(1-(offsetStrength*7),0)*25, 0), 
          c_purple, c_purple);
  }

  size = max( max(1-(offsetStrength*5),0)*18, 0);
  for (var i = 0; i &lt; segmentCount; i++;){
      draw_line_width_colour(
          segmentsX[i],segmentsY[i],segmentsX[i+1],segmentsY[i+1], 
          size, 
          c_white, c_white);

  }
  draw_circle_colour(startX, startY, size*random_range(0.9,1.1), c_white, c_white, false);
  draw_circle_colour(endX, endY, size*random_range(0.9,1.1), c_white, c_white, false);
}
flashing = !flashing;

  size = max( max(1-(offsetStrength*5),0)*18, 0);
if(offsetTime == offsetDuration){
    draw_circle_colour(startX, startY, size*random_range(0.9,1.1), c_black, c_black, false);
    draw_circle_colour(endX, endY, size*random_range(0.9,1.1), c_black, c_black, false);
} else {
    draw_circle_colour(startX, startY, size*random_range(0.9,1.1), c_white, c_white, false);
    draw_circle_colour(endX, endY, size*random_range(0.9,1.1), c_white, c_white, false);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if(attacking) event_user(0); //Draw the magic bolt
else event_user(1);


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
