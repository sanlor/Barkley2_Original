<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>icon_parent</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Entity</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Extend Entity creation with further declarations
event_inherited()

uuid = uuid_generate();

// Path initialization
scr_path_init()

// Actors turn dark in shadows
in_shadow = false;

// Actors can't leave the room usually
can_leave_room = false;

// Actors default to circle moveboxes - better but more processing involved
scr_entity_setMovementCollisionShape_circle(8)

// Create a sound emitter for each Actor by default
scr_entity_makeSoundEmitter();

// Storage for variables during pause
paused_path_speed = 0;

// Flag to indicate if object supports paths - Actor does
path_support = true;

// Set whether object is Surfaced or not
surf = NULL;
use_surface=false;

// Actors can be rigid. If they are, they can not move
actor_rigid = false
actor_rigid_set = false
actor_rigid_semisolid = true

// This is used by pedestrians and their shadows // Laz added, 17.12.2015
alpha = 1;

// Facing
_pedestrian = false;
flipAuto = 0; //If 1, the sprite can mirror itself
faceAuto = 0; //Only do facing scripts if we define them
idleAuto = ""; //If not blank, sets to that animation when a cinema is over
East = 2; //from obsolete stair code in step
West = 3; //from obsolete stair code in step
walkBackwards = 0; //When enabled, reverse animate
statusImmuneAll = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cleanup resources

// Remove paths
scr_path_delete();

// Remove rigid
if (actor_rigid_set) {
    if (actor_rigid_semisolid) {
        scr_collisionSystem_remove_shape_semisolid(_sat_shape)
    }
    else {
        scr_collisionSystem_remove_shape_solid(_sat_shape)
    }
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update audio emitter location
audio_emitter_position(sound_emitter, x, y, z);
//audio_emitter_velocity(sound_emitter, move_x, move_y, move_z);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set/Unset rigid

scr_actor_instantRigid(id);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for shadows
event_inherited();
if paused() exit;

// Check for shadows
//in_shadow = !scr_collision_point_free(x, y, z, COLLISION_SHADOWS);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Prevent Actors from leaving the room

if(!can_leave_room)
{
    if (x &lt; 8) x = 8;
    if (x &gt; room_width - 8) x = room_width - 8;
    if (y &lt; 8) y = 8;
    if (y &gt; room_height - 8) y = room_height - 8;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ACTORS OVERRIDE STEP CODE (NO INHERITED CODE)</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle pausing
if (paused()) {

    // Store built-in behaviour-affecting variables during pause
    if (image_speed != 0) {
        paused_image_speed = image_speed;
        image_speed = 0;
    }

    // Stop paths
    path_speed = 0;
}
else {
    // Restore built-in behaviour-affecting variables during pause
    if (paused_image_speed != 0) {
        image_speed = paused_image_speed;
        paused_image_speed = 0;
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Perform all movement code (Extended with: Paths, Stairs)
if paused() exit;

var onGround = false;
if (z &lt;= base_z &amp;&amp; move_z &lt;= 0 ) {
    onGround = true;
}
var _zprev;
_zprev = z;

if (actor_rigid_set or (move_x == 0 and move_y == 0 and !scr_path_active())) {
    // Rigid actors don't move!
    move_x = 0
    move_y = 0
    mz = move_z * dt();
    
    delta_x = 0
    delta_y = 0
    move_dir = 0
    move_dist = 0
    
    movement_hit = false;
} else {
    // Perform movement (only if path does not exist)
    if (scr_path_active()) {
        scr_path_update();
        script_execute(path_movementScript, "step");
    }
    
    // Copied movement vector taking delta time into account.
    var mx = move_x * dt();
    var my = move_y * dt();
    var mz = move_z * dt();
    
    // Slow in stairs
    var stairs;
    var cx = floor(x/8);
    var cy = floor(y/8);
    if (cx &gt;= 0 and cy &gt;= 0) {
        stair = ds_grid_get(sys_collision.c_stgrid, cx, cy)
    } else {
        stair = 0;
    }
    
    var zstair = scr_collision_zstair(x, y);
    
    // Elevate on horizontal stairs
    var stair_ydiff;
    stair_ydiff = 0;
    if (abs(mx) &gt; 0 and (stair = East or stair = West)) {
        stair_ydiff = mx * scr_math_nsign(stair = East);
    }

    if (stair or !is_undefined(zstair)) {
        mx /= 1.5;
        my /= 1.5;
    }

    var _xprev, _yprev;
    _xprev = x;
    _yprev = y;
    movement_hit = scr_collision_move_contact_solid(mx, my - stair_ydiff, collision_check);
    if (movement_hit) {
        movement_hit_vx = __vx
        movement_hit_vy = __vy
    }
    delta_x = x - _xprev;
    delta_y = y - _yprev;
    
    // Apply friction
    if (move_friction &gt; 0 &amp;&amp; (move_x != 0 || move_y != 0)) {
        var dir, dist;
        dist = point_distance(0, 0, move_x, move_y);
        dir = point_direction(0, 0, move_x, move_y);
        dist = max(0, dist - (move_friction * dt()));
        move_x =  cos(degtorad(dir)) * dist;
        move_y = -sin(degtorad(dir)) * dist;
    }
    
    // Convert movement vector to dir/dist for easy use in scripts/code
    move_dir = point_direction(0, 0, move_x, move_y)
    move_dist = point_distance(0, 0, move_x, move_y)
    
    // Handle walking on Z stairs
    if (onGround and move_dist &gt; 0) {
        zstair = scr_collision_zstair(x, y);
        if (!is_undefined(zstair)) {
            if (zstair == ZSTAIRS_LEFT and move_x &gt; 0) {
                z -= move_x;
            }
            if (zstair == ZSTAIRS_RIGHT and move_x &lt; 0) {
                z += move_x;
            }
            if (zstair == ZSTAIRS_UP and move_y &gt; 0) {
                z -= move_y;
            }
        }
    }
}

// Base Z (from heightmap)
base_z = scr_entity_getZHeight();

// Perform Z movement
if (z &lt;= base_z &amp;&amp; move_z &lt;= 0 ) {
    move_z = 0;
}
else {
    z += mz;
}
if (z &lt; base_z) {
    z = base_z;
}
delta_z = z - _zprev;
    
// Apply gravity
move_z -= gravity_z * dt();

// Rendering depth
scr_dny(dny)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle animations
if paused() exit;

scr_entity_animation_step_all();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ACTORS OVERRIDE DRAW CODE (NO INHERITED CODE)
// Draw shadow    
if (shadow_visible) {
    if (shadow_sprite_index != NULL) {
        // Draw shadow sprite
        draw_set_color(c_white);
        draw_set_alpha(1)
        draw_sprite_ext(shadow_sprite_index, shadow_image_index, x+shadow_sprite_offset_x, y+shadow_sprite_offset_y-base_z, image_xscale, image_yscale, image_angle, c_black, shadow_strength);
    }
    else {
        // Draw shadow circle
        //draw_set_color(c_black);
        var shadow_alpha = shadow_strength * image_alpha;
        if (_pedestrian) shadow_alpha = shadow_strength * alpha;
        var _radius;
        if (shadow_radius = -1) {
            _radius = scr_entity_getMovementCollisionShapeRadius();
        }
        else {
            _radius = shadow_radius;
        }
        _radius = _radius * (1 / (1 + ((z - base_z) / 100))) // Scale shadow with Z height 
        
        var dvv = (1 / 64) * 2; // so i don't have to muck with radius
        
        draw_sprite_ext(s_lensflare, 0, round(x + shadow_sprite_offset_x), round(y + shadow_sprite_offset_y - base_z), 
            _radius * dvv, (_radius * 0.5) * dvv, 0, c_black, shadow_alpha);
        
        // OLD SHADOWS
        //draw_set_alpha(shadow_alpha);
        //draw_ellipse(x + shadow_sprite_offset_x - _radius, y + shadow_sprite_offset_y - base_z - (_radius * .5),
        //             x + shadow_sprite_offset_x + _radius, y + shadow_sprite_offset_y - base_z + (_radius * .5),
        //             false);
        //draw_set_alpha(1); // needed or stuff loks bad
        
    }
}

// Calculate and export draw coordinates
dx = x;
dy = y - z;


exit; 
// Set draw color and alpha - Obsolete code?
if (in_shadow) {
    draw_set_color(make_color_rgb(150, 150, 150));
    draw_set_alpha(1)
    image_blend = make_color_rgb(150, 150, 150);
    //image_alpha = 1; // was messing up o_object_alpha
}
else {
    draw_set_color(c_white);
    draw_set_alpha(1)
    image_blend = c_white;
    //image_alpha = 1; // was messing up o_object_alpha
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
