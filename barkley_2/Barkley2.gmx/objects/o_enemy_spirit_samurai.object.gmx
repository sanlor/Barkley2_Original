<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_spirit_samurai</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>EnemyCombatActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////you get all the default variables from EnemyCombatActor
event_inherited();

// Enemy stats
scr_enemyDB_statsGet(enemyBuild);

// Enemy configurations
channel=false;
scr_entity_setZHitbox(0, 32);
anim = 0;
animSpd = 0.2;
animStrike = 0;

scr_stats_hook_onHit_userEvent(8);

deathSound = "cGremlinSmall_death";
damageSound = "cGremlinSmall_grunt";



// Passive and active states
var conf;
scr_AI_addPassiveState(scr_AI_passive_none);
activeApproach = scr_AI_addActiveState(scr_AI_active_approach);
activeCircle = scr_AI_addActiveState(scr_AI_active_circle);
activeCircle[? "switchAddMaxDist"] = 80;
activeCircle[? "switchPriority"] = 10;


// Create and configure AI switch
/////////////////////setup AI Switch and attacks
_aiswitch = scr_AI_setSwitch(scr_AI_switch_conditions);
_aiswitch[? "attackInterval"]=10; ///added interval between every attack
attacks = ds_map_find_value(_aiswitch, "attacks");


//Katana Attack
conf = scr_AI_addAction(scr_AI_action_userEvent);
conf [? "userEvent"] =2;
conf [? "attackName"] ="Tamahagane no Rambo";
conf [? "beforeTime"] =6;
conf [? "damageTime"] =2;
conf [? "afterTime"] =4;
conf [? "rechargeTime"] =15;

attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority",8);
ds_map_add(attack, "actionMap", conf);
ds_map_add(attack, "distMin", 100);
ds_map_add(attack, "distMax", 200);
ds_list_add(attacks, attack);
///Attack performed if target is at mid to high range
ds_map_add(attack, "noRepeat", false);


//Naginata Attack
conf = scr_AI_addAction(scr_AI_action_userEvent);
conf [? "userEvent"] =2;
conf [? "attackName"] ="Naginata no Meiwaku";
conf [? "beforeTime"] =4;
conf [? "damageTime"] =8;
conf [? "afterTime"] =3;
conf [? "rechargeTime"] =25;

attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority",8);
ds_map_add(attack, "actionMap", conf);
ds_map_add(attack, "distMin", 48);
ds_map_add(attack, "distMax", 96);
ds_list_add(attacks, attack);
///Attack performed if target is at mid to high range
ds_map_add(attack, "noRepeat", false);


//Kunai Attack
conf = scr_AI_addAction(scr_AI_action_userEvent);
conf [? "userEvent"] =2;
conf [? "attackName"] ="Ganko Kunai";
conf [? "beforeTime"] =4;
conf [? "damageTime"] =3;
conf [? "afterTime"] =3;
conf [? "rechargeTime"] =10;

attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority",8);
ds_map_add(attack, "actionMap", conf);
ds_map_add(attack, "distMin", 32);
ds_map_add(attack, "distMax", 240);
ds_list_add(attacks, attack);
///Attack performed if target is at mid to high range
ds_map_add(attack, "noRepeat", false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ATTACK ACTIONS

var movSpd = 0;
var turnSpd = 0;


////THIS HANDLES ALL OF OOZES' ATTACK ACTIONS:
switch(a_attackState)
{
    case "reset": ///reset attack actions' timing vars
        I_atk_evnt_intBefore = ds_map_find_value(conf, "beforeTime");
        I_atk_evnt_intDamage = ds_map_find_value(conf, "damageTime");
        I_atk_evnt_intAfter = ds_map_find_value(conf, "afterTime");
        I_atk_evnt_didAttack = false;
        a_attackState = "before";
        didAtk=false;
        didAtk2=false;
        knockback_ripple=0;
        face_hoopz =choose(-1,1);
        scr_entity_setMoveXY(0, 0);
        break;
        
    case "before": ///timing before any attack anim
        switch(a_attackName) 
        {
            case "Tamahagane no Rambo":
                face_hoopz =choose(-1,1);
                faceDir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
                break;
                
            case "Naginata no Meiwaku":
                faceDir = point_direction(x,y,x,y+32);
                break;
                
            case "Ganko Kunai":
                faceDir = point_direction(x,y,x,y+32);
                break;
        }
        
        if(a_attackAnim&lt;I_atk_evnt_intBefore)
        {
            a_attackAnim+= dt();
        }
        else
        {
            a_attackAnim = 0;
            a_attackState = "damage";
            spawnAtkObj = true;
        }
        break;
        
    case "damage": ///action itself
        switch(a_attackName)
        {
            case "Tamahagane no Rambo":
            if didAtk==false
                {
                didAtk=true;
                var n;
                n = instance_create(x, y, o_enemyAttack_melee_animation);
                n.sprite_index = s_spirit_samurai_slash;
                n.lifetime = 3;
                n.parent = id;
                n.visible=true;
                scr_stats_setAttackStat(n,STAT_ATTACK_DMG_NORMAL,15);
                ds_list_copy(n.target_list, target_list);
                if face_hoopz ==-1
                    {
                    n.x= o_hoopz.x;
                    n.y=o_hoopz.y;
                    n.image_yscale=-1;
                    }
                else if face_hoopz ==1
                    {
                    n.x= o_hoopz.x;
                    n.y=o_hoopz.y;
                    n.image_xscale=1;
                    }
                }
  
                if(a_attackAnim &lt; I_atk_evnt_intDamage)
                {
                    a_attackAnim+= dt();
                }
                else
                {
                    a_attackAnim = 0;
                    a_attackState = "after";
                }
                
                break;
                
            case "Naginata no Meiwaku":
                movSpd =0;
                    var n, ax, ay, _dist;
                    _dist = 96;
                    ax = cos(degtorad(faceDir))* _dist;
                    ay = -sin(degtorad(faceDir))* _dist;
                    n = instance_create(x + ax, y + ay, o_enemyAttack_melee_static);
                    n.sprite_index=mask_rect_16by16;
                    n.parent = id;
                    n.lifetime = 1;
                    n.offset_x = ax;
                    n.offset_y = ay;
                    n.visible=true;
                    scr_stats_setAttackStat(n,STAT_ATTACK_DMG_NORMAL,10);
                    ds_list_copy(n.target_list, target_list);
                    
                    n = instance_create(x + (ax*0.9), y + (ay*0.9), o_enemyAttack_melee_static);
                    n.sprite_index=mask_rect_16by16;
                    n.parent = id;
                    n.lifetime = 1;
                    n.offset_x = ax*0.9;
                    n.offset_y = ay*0.9;
                    n.visible=true;
                    scr_stats_setAttackStat(n,STAT_ATTACK_DMG_NORMAL,10);
                    ds_list_copy(n.target_list, target_list);
                faceDir+=8;
                if(a_attackAnim &lt; I_atk_evnt_intDamage)
                {
                    a_attackAnim+= dt();
                }
                else
                {
                    a_attackAnim = 0;
                    a_attackState = "after";
                }
                
                break;
                
                
            case "Ganko Kunai":
                movSpd =0;
                
                if didAtk==false
                    {
                    didAtk=true;
                    for(i=0; i &lt;8; i++)
                        {
                        var _blt = instance_create(x,y,o_enemyAttack_bulletKunai);
                        _blt.z =8;
                        _blt.life = 10;
                        scr_stats_setAttackStat(_blt, STAT_ATTACK_DMG_NORMAL, 8);
                        _blt.dmg_dir = 360/8*i;
                        _blt.dir = 360/8*i;
                        _blt.spd=18;
                        with _blt {scr_entity_setDirSpd(dir, spd);}
                        if (instance_exists(I_AI_target)) ds_list_add(_blt.target_list, I_AI_target.object_index);  
                        ds_list_add(_blt.target_list, DestructibleCombatActor); //GZ Added for hitting barrels etc  
                        ds_list_add(_blt.target_list, BlockingCombatActor); //GZ Added for hitting barrels etc  
                        _blt.sprite_index=s_bull_arrow;
                        }
                    }
  
                if(a_attackAnim &lt; I_atk_evnt_intDamage)
                {
                    a_attackAnim+= dt();
                }
                else
                {
                    a_attackAnim = 0;
                    a_attackState = "after";
                }
                
                break;
        }
        break;
        
    case "after": ///timing after attack anim
    
          switch(a_attackName)
        {
            case "Tamahagane no Rambo":
            break;
            case "Naginata no Meiwaku":
                    for(i=0; i &lt; 32; i++)
                        {
                        var n, ax, ay, _dist, _dir;
                        _dist = 72+knockback_ripple;
                        ax = cos(degtorad((360/32)*i)) * _dist;
                        ay = -sin(degtorad((360/32)*i)) * _dist;
                        n = instance_create(x + ax, y + ay, o_enemyAttack_melee_static);
                        n.sprite_index=mask_rect_8by8;
                        n.mask_index=mask_rect_8by8;
                        n.parent = id;
                        n.lifetime = 0.5;
                        n.offset_x = ax;
                        n.offset_y = ay;
                        n.dx = cos(degtorad((360/16)*i))*8;
                        n.dy = -sin(degtorad((360/16)*i))*8;
                        n.visible=true;
                        _dir=(360/32)*i;
                        scr_stats_setAttackStat(n,STAT_ATTACK_DMG_NORMAL,2);
                        scr_stats_setAttackStat(n,STAT_ATTACK_KNOCKBACK,12);
                        n.knockback_dir = _dir;
                        ds_list_copy(n.target_list, target_list);
                    }
                    knockback_ripple+=3;
            break;
        }
    
        if (a_attackAnim &lt; I_atk_evnt_intAfter)
        {
            a_attackAnim += dt();
        }
        else
        {
            a_attackState = "reset";
            stateResult = AI_STATERESULT_REMOVE;
            scr_entity_setMoveXY(0, 0);
        }
        break;
}

show_debug_message(a_attackState);

/////HANDLES MOVEMENT DURING ATTACK PATTERNS
if(turnSpd&gt;0)
{
    scr_AI_util_turnTowards(I_AI_target.x,I_AI_target.y, turnSpd);
    direction = faceDir;
}

if(movSpd&gt;0)
{
    show_debug_message(string(movSpd));
    move_x =  cos(degtorad(direction)) * movSpd;
    move_y = -sin(degtorad(direction)) * movSpd;
}
else
{
    move_x = 0;
    move_y = 0;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

draw_sprite_ext(sprite_index,0,dx,dy,1,1,0,c_white,1);

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>22,49</point>
    <point>28,28</point>
  </PhysicsShapePoints>
</object>
