<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2710000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create
executeSkip = 0; // Go to DNA strand
gunsurface = surface_create(160,160);

////////// EDITABLE VALUES
audio_play_sound_ext("mus_gunfuse_track", 10, 0);
soundSwitchBackground = "sn_mnu_switchRoomEnter01"; // 2.3 second sound plays when switch scene first begin
soundSwitch = "sn_mnu_switchFlick01"; // Plays on each switch flick
soundPullBackground = "sn_mnu_bigSwitch01"; // 2.5 second sound that plays during hoopz pulling big switch
soundInfoBackground = "sn_mnu_gunInfoScreen01"; // 3 second sound for when the gun info is on screen
soundGunsmapBackground = "sn_mnu_gunsmapScene01"; // 4 second sound for when the gunsmap is on screen
soundButton = "sn_mnu_loveButtonTransition01"; // sound for when the love button is hit
soundButtonBackground = "sn_mnu_buttonBackground01"; // 1.85 second sound that plays during button scene
// ^^^ the first 1.5 seconds are of the button push, 1.5 to 1.85 are when the transition starts
soundDNAOpen = "sn_mnu_DNAOpen"; // sound when furnace opens up
soundDNABackground = "sn_mnu_dnaSpliceScene"; // 12 second sound that plays for the DNA splicing scene

switchFlick = 4;
switchHandSpeed = 7;
pullAnimationSpeed = 6;
mapBasicSprite = 0; // If 1, use green generic type sprites, otherwise use REAL sprite of gun

gunsmapScale = 2;
gunsmapStatic = 1;
gunsmapTopFadeIn = 0.75;
gunsmapInterim = 0.5;
gunsmapBottomFadeIn = 0.75;
gunsmapHold = 0.5;
gunsmapLineConnect = 1;
gunsmapReticleFlash = 1;
finalWait = 1; // Seconds to freeze on end of gun fuse
fadeBegin = 1; fadeBeginSpeed = 4;
fadeHand = 1; fadeHandSpeed = 2;
fadeExit = 0; fadeExitSpeed = 2;
gunShift = 0; gunShiftSpeed = 1;
gunShiftWait = 0; gunShiftWaitSpeed = 1;
gunPause = 0; gunPauseSpeed = 1;
gunTextWait = 0; gunTextWaitSpeed = 1;
gunFinal = 1;
menuDid = 0;
fadeExitActivate = 0;
fadeDarling = 1;
darling = Utility("quote");

/////////////////////////////// NOT NEEDED AFTER INTEGRATE
//gun1 = ds_map_create(); set from arguments
//gun2 = ds_map_create(); set from arguments
gridx = 0;
gridy = 0;
gridxspd = (5+random(20))*choose(1,-1);
gridyspd = (5+random(20))*choose(1,-1);
//event_user(2);
//with(obj_breedanm_parentpanels) instance_destroy();
/////////////////////////////// NOT NEEDED AFTER INTEGRATE

/////////////////////////////// GENERAL
CinemaFusion("setup");
x = 150 - (192 / 2);
y = (240 / 2) - (120 / 2);
flashColor = c_white;
flashSpeed = 0;
flashAlpha = 0;
aniSpd = 6; // Speed of animations
state = "hand";
tim = get_timer();

///////// START ANIMATION
event_user(15);
hndAct = 1;
state = "hand";

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy
audio_stop_sound_ext("mus_gunfuse_track");
with (ustation) Utility("input", 1);
surface_free(gunsurface);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Step
if (fadeBegin &gt; 0) exit;
if (fadeHand &gt; 0) exit;

// SKIP
if (executeSkip == 0 &amp;&amp; MiniKeyPress("action"))
{
    audio_stop_sound_ext("mus_gunfuse_track");
    event_user(15);
    state = "dna";
    event_user(5);
}
// SKIP

if (state == "hand")
{
    event_user(0);
}
else if (state == "pull")
{
    if (pulTim == 0) audio_play_sound_ext(soundPullBackground, 10, 0);
    pulTim += dt_sec();
    pulAni += dt_sec() * pullAnimationSpeed;
    if (pulAni &gt;= pulMax) 
    {
        pulAni = pulMax - 1; 
        state = "info";
        show_debug_message("Time for PULL: " + string(pulTim * 1000) + "ms.");
        event_user(2);
    }
}
else if (state == "info")
{
    if (gunTim == 0) audio_play_sound_ext(soundInfoBackground, 10, 0);
    gunTim += dt_sec();
    
    /*if(gunTim&gt;=2)///open up interface
    {
        with(obj_breedanm_parentpanels){event_user(1);}
    }*/
    
    if (gunTim &gt;= 2)
    {
        show_debug_message("Time for INFO: " + string(gunTim * 1000) + "ms.");
        event_user(6);
        state = "map";
    }
}
else if (state == "button")
{
    if (butTim == 0) audio_play_sound_ext(soundButtonBackground, 10, 0);
    butTim += dt_sec();
    fstDel += dt_sec();
    if (fstDel &gt;= 0.5)
    {
        fstX = Goto(fstX, fstDesX, fstSpdX * dt_sec());
        fstY = Goto(fstY, fstDesY, fstSpdY * dt_sec());
        
        if (fstX == fstDesX &amp;&amp; fstY &amp;&amp; fstDesY)
        {
            fstPau -= dt_sec();
            if(fstPau&gt;0.30)
            {
                fstRot = Goto(fstRot, -8, fstSpdRot/2 * dt_sec());
            }
            else if(fstPau&gt;0.25)
            {
                fstRot = Goto(fstRot, -6, fstSpdRot/6 * dt_sec());
            }
            else if(fstPau&gt;0.20)
            {
                fstRot = Goto(fstRot, -6, fstSpdRot/10 * dt_sec());
            }
            else
            {
                fstRot = Goto(fstRot, -15, fstSpdRot/8 * dt_sec());
            }
            if (btnFrame == 0) audio_play_sound_ext(soundButton, 10, 0);
            btnFrame = 1;
            txtFrame += 10*dt_sec();
            if(txtFrame&gt;=5){txtFrame-=5;}
            if (fstPau &lt;= 0)
            {
                //flashAlpha = 1;
                //flashSpeed = 0.5;
                show_debug_message("Time for BUTTON: " + string(butTim * 1000) + "ms.");
                event_user(5);
                state = "buttonTransit";
            }
        }
        else
        {
            fstRot = Goto(fstRot, fstDesRot, fstSpdRot * dt_sec());
        }
    }
}
else if (state == "buttonTransit")
{
    bTranTim += dt_sec();
    bTranAni += dt_sec() * 16;
    if (bTranAni &gt;= bTranMax) 
    { 
        dnaSub += dt_sec() * aniSpd;
        bTranAni = bTranMax - 1; 
        state = "dna";
        show_debug_message("Time for Transition: " + string(bTranTim * 1000) + "ms.");
    }
}
else if (state == "map")
{

    with(obj_breedanm_parentpanels)
    {
        other.mapOpen = openWidth;
        other.mapAlphaGlob = median(0,1,openWidth/100);
        event_user(1);
    }
    
    if(!instance_exists(obj_breedanm_parentpanels)){mapAlphaGlob = 1;}
    
    if (mapTim == 0) audio_play_sound_ext(soundGunsmapBackground, 10, 0);
    mapTim += dt_sec();
    mapCou += dt_sec();
    
    
    if (mapState == 0) ///
    {
        surZoom = 0.5;
        if (mapCou &gt;= gunsmapStatic) { mapCou = 0; mapState += 1; }
    }
    else if (mapState == 1)
    {
        surFocusXTo = gunTopX; surFocusYTo = gunTopY;
        surFocusSpd = 35+70*mapCou;
        if(surZoom&lt;1){ surZoom += 1*dt_sec()}else{surZoom = 1;}
        mapAl0 = Goto(mapAl0, 1, dt_sec() / gunsmapTopFadeIn); ///first gun appears
        if (mapCou &gt;= gunsmapTopFadeIn) { mapCou = 0; mapState = 1.5; }
    }
    else if (mapState == 1.5)
    {
        if (mapCou &gt;= gunsmapInterim) { mapCou = 0; mapState = 2; }
    }
    else if (mapState == 2)
    {
        surFocusXTo = gunBotX; surFocusYTo = gunBotY;
        surFocusSpd = 35+70*mapCou;
        mapAl1 = Goto(mapAl1, 1, dt_sec() / gunsmapBottomFadeIn); ///second gun appears
        if (mapCou &gt;= gunsmapBottomFadeIn) { mapCou = 0; mapState += 1; }
    }
    else if (mapState == 3)
    {
        if (mapCou &gt;= gunsmapHold) { mapCou = 0; mapState += 1; }
    }
    else if (mapState == 4) // map connect
    {
        surFocusXTo = gunMrgX; surFocusYTo = gunMrgY;
        surFocusSpd = 25+70*mapCou;
        mapPro = Goto(mapPro, 1, dt_sec() / gunsmapLineConnect); ////guns connect
        if (mapCou &gt;= gunsmapLineConnect) { mapCou = 0; mapState += 1; }
    }
    else if (mapState == 5)
    {
        if (mapCou &gt;= gunsmapReticleFlash) 
        {
            show_debug_message("Time for MAP: " + string(mapTim * 1000) + "ms.");
            state = "button";
        }
    }
    
    surFocusX = Goto(surFocusX,surFocusXTo,dt_sec()*surFocusSpd);
    surFocusY = Goto(surFocusY,surFocusYTo,dt_sec()*surFocusSpd);
    
    exit;
    if (flashAlpha &lt;= 0) mapAl0 = Goto(mapAl0, 1, dt_sec());
    if (mapAl0 == 1) mapAl1 = Goto(mapAl1, 1, dt_sec());
    if (mapAl1 == 1) mapPro = Goto(mapPro, 1, dt_sec());
    if (mapTim &gt;= 2.5)
    {
        show_debug_message("Time for MAP: " + string(mapTim * 1000) + "ms.");
        state = "button";
    }
}
else if (state == "dna")
{
    if (dnaTim == 0) audio_play_sound_ext(soundDNABackground, 10, 0);
    dnaTim += dt_sec();
    dnaSub += dt_sec() * aniSpd;
    if (dnaTim &gt; 2.5)
    {
        var spd = 120;
        var chkpos = abs(dnaY);
        if(chkpos&lt;60){spd = median(20,120,chkpos*2);}
        if(chkpos&gt;100){spd = median(20,120,(60-(chkpos-100))*2);}
        //show_debug_message("SCROLL SPEED:"+string(spd));
        dnaY -= dt_sec() * spd;
        dnaY = max(dnaY, -160);
    }
    //if (dnaY == -120)
    //{
    dnaPmp += dt_sec() * aniSpd * dnaMul;
    dnaPmp += (dnaPmp / 10) * dt_sec() * dnaMul;
    if (dnaPmp &gt; 48) dnaMul = 1 - (min(dnaPmp - 48, 10) / 10);
    //dnaPmp = min(dnaPmp, 48);
    //}
    if (dnaPmp &gt;= 48)
    {
        dnaOpn -= dt_sec() * 10;
        dnaOpn = max(dnaOpn, 0);
    }
    if (dnaOpn != 39 &amp;&amp; dnaOne == 1) { dnaOne = 2; audio_play_sound_ext(soundDNAOpen, 10, 0); }
    if (dnaOpn == 0)
    {
        dnaAlp -= dt_sec() * 0.7;
        dnaAlp = max(dnaAlp, 0);
        if (dnaAlp &lt; 0.5) dnaGunAlp -= dt_sec() / 2;
        dnaGunAlp = max(dnaGunAlp, 0);
        if (dnaGunAlp == 0 &amp;&amp; dnaOne == 2) { state = "final wait"; dnaOne = 0; show_debug_message("Time for DNA: " + string(dnaTim * 1000) + "ms."); }
    }
}
else if (state == "final wait")
{
    finalWait -= dt_sec();
    if (finalWait &lt;= 0)
    {
        if (fadeExit == 0) { with (ustation) event_user(15); }
        fadeExit += dt_sec() * fadeExitSpeed;
        fadeExit = min(1, fadeExit);
        if (fadeExit &gt;= 1) state = "final fade";
    }
}
else if (state == "final fade")
{
    if (gunShift &lt; 1)
    {
        gunShift += dt_sec() * gunShiftSpeed;
        gunShift = min(gunShift, 1);
        exit;
    }
    if (gunShiftWait &lt; 1)
    {
        gunShiftWait += dt_sec() * gunShiftWaitSpeed;
        gunShiftWait = min(gunShiftWait, 1);
        exit;
    }
    if (menuDid == 0) { menuDid = 1; }
    if (gunPause &lt; 1)
    {
        gunPause += dt_sec() * gunPauseSpeed;
        gunPause = min(gunPause, 1);
        exit;
    }
    if (gunTextWait &lt; 1)
    {
        gunTextWait += dt_sec() * gunTextWaitSpeed;
        gunTextWait = min(gunTextWait, 1);
        exit;
    }
    if (MiniKeyPress("action")) fadeExitActivate = 1;
    if (fadeExitActivate == 0) exit;
    fadeDarling -= dt_sec() * 2;
    fadeDarling = max(0, fadeDarling);
    if (fadeDarling &gt; 0) exit;
    fadeExit -= dt_sec() * fadeExitSpeed;
    fadeExit = max(0, fadeExit);
    gunFinal -= dt_sec() * fadeExitSpeed;
    gunFinal = max(0, gunFinal);
    if (fadeExit &lt;= 0) instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset variables
with (obj_breedanm_parentpanels) instance_destroy();
with (oPuff) instance_destroy();
with (oSmoke) instance_destroy();
////////////////////////////////////// HAND
hndTim = 0;
hndAct = 0;
hndX = -36;
hndY = 120 + 8;
hndAcc = 1;
hndMom = switchHandSpeed;
hndSpd = 0;
hndTar = 0;
hndStt = 0;
hndSub = 2;
hndWa0 = 0.1;
hndWa1 = 0.1;
hndWa2 = 0.05;
hndCou = 0;

redLightFrm = 0;
greenLightFrm = 0;

for (i = 0; i &lt; 10; i += 1) swiSub[i] = 0; // EXTRA
swiSub[9] = 1;
i = 0;
swiX[i] = 39; swiY[i] = 66; i += 1;
swiX[i] = 54; swiY[i] = 68; i += 1;
swiX[i] = 69; swiY[i] = 70; i += 1;
swiX[i] = 85; swiY[i] = 72; i += 1;
swiX[i] = 101; swiY[i] = 75; i += 1;
swiX[i] = 117; swiY[i] = 78; i += 1;
swiX[i] = 134; swiY[i] = 80; i += 1;
swiX[i] = 151; swiY[i] = 83; i += 1;
swiX[i] = 167; swiY[i] = 85; i += 1;
swiX[i] = 167 + 64; swiY[i] = 85 + 64; i += 1;
dslSwi = ds_list_create();
for (i = 0; i &lt; 9; i += 1) ds_list_add(dslSwi, i);
ds_list_shuffle(dslSwi);
hndTar = 999;
for (i = 0; i &lt; switchFlick; i += 1) // was 5
{
    hndTar = min(hndTar, dslSwi[| i]);
    swiSub[dslSwi[| i]] = 1;
}
ds_list_destroy(dslSwi);
//swiSub[2] = 0; swiSub[3] = 0; swiSub[5] = 0; swiSub[7] = 0;

i = 0;
mtrX[i] = 38;  mtrY[i] = 16; i += 1;
mtrX[i] = 52;  mtrY[i] = 17; i += 1;
mtrX[i] = 66;  mtrY[i] = 19; i += 1;
mtrX[i] = 81;  mtrY[i] = 21; i += 1;
mtrX[i] = 96;  mtrY[i] = 23; i += 1;
mtrX[i] = 112; mtrY[i] = 25; i += 1;
mtrX[i] = 129; mtrY[i] = 27; i += 1;
mtrX[i] = 146; mtrY[i] = 29; i += 1;
mtrX[i] = 162; mtrY[i] = 31; i += 1;
for (i = 0; i &lt; 9; i += 1) 
{
    mtrSub[i] = 0;
    if (swiSub[i] == 0)  mtrSub[i] = 11;
    mtrX[i] -= 1;
}
////////////////////////////////////// HAND

////////////////////////////////////// PULL
pulTim = 0;
pulAni = 0;
pulMax = sprite_get_number(sCinemaHoopzPull);
////////////////////////////////////// PULL

////////////////////////////////////// INFO
gunTim = 0;
gunOne = 0;
gridxspd = (5+random(20))*choose(1,-1);
gridyspd = (5+random(20))*choose(1,-1);
gridx = 0;
gridy = 0;
////////////////////////////////////// INFO

////////////////////////////////////// MAP
mapOpen = 0;
mapTim = 0;
mapAl0 = 0;
mapAl1 = 0;
mapPro = 0;
mapCou = 0;
mapState = 0;
mapRot = 0;
surFocusX = 80;
surFocusY = 80;
surFocusXTo = 80;
surFocusYTo = 80;
surFocusSpd = 40;
surZoom = 2;
mapAlphaGlob = 0;
////////////////////////////////////// MAP

/////////////////////////////////////// BUTTON TRANSITION
bTranTim = 0;
bTranAni = 0;
bTranMax = sprite_get_number(sCinemaButtonTransition);
/////////////////////////////////////// BUTTON TRANSITION

////////////////////////////////////// DNA
dnaGnx[0] = 12 + 2; dnaGny[0] = 9 + 2;
dnaGnx[1] = 131 - 2; dnaGny[1] = 87 - 2;
dnaY = 0;
dnaCou = 0;
dnaTim = 0;
dnaSub = 0;
dnaPmp = 0;
dnaOpn = 39;
dnaOne = 1; // For sound
dnaAlp = 1;
dnaGunAlp = 1;
dnaMul = 1;
dnaSmk = 0.05; // how often smoke happens
dnaSmkCou = 0;
dnaNamAlp = 0;
dnaInfAlp = 0;
////////////////////////////////////// DNA

////////////////////////////////////// BUTTON
btnFrame = 0;
txtFrame = 0;
butTim = 0;
fstDel = 0;
fstPau = 0.5;
fstX = -64;
fstY = 64;
fstRot = 45;
fstDesX = 8;
fstDesY = 80;
fstDesRot = -20;
fstDiv = 0.5;
fstSpdX = abs(fstX - fstDesX) / fstDiv;
fstSpdY = abs(fstY - fstDesY) / fstDiv;
fstSpdRot = abs(fstRot - fstDesRot) / fstDiv;
////////////////////////////////////// BUTTON
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw
var gunSpr1 = assetOrNull(gun1[? "hudIconSprite"], asset_sprite);
var gunImg1 = gun1[? "hudIconFrame"];
var gunSpr2 = assetOrNull(gun2[? "hudIconSprite"], asset_sprite);
var gunImg2 = gun2[? "hudIconFrame"];
var gunSpr3 = assetOrNull(gun3[? "hudIconSprite"], asset_sprite);
var gunImg3 = gun3[? "hudIconFrame"];
    
x = 150 - (192 / 2) + view_xview[0];
y = (240 / 2) - (120 / 2) + view_yview[0];
drx = x; dry = y;
vrx = view_xview[0]; vry = view_yview[0];
if (fadeBegin &gt; 0) { fadeBegin -= dt_sec() * fadeBeginSpeed; fadeBegin = max(0, fadeBegin); }
if (state != "final fade") draw_sprite_ext(s1x1, 0, vrx, vry, 640, 480, 0, c_black, abs(fadeBegin - 1));
if (fadeBegin &gt; 0) exit;
if (fadeHand &gt; 0) { fadeHand -= dt_sec() * fadeHandSpeed; fadeHand = max(0, fadeHand); }
if (state == "hand")
{
    alpha = abs(1 - fadeHand);
    draw_sprite_ext(sCinemaSwitchPlate, 0, drx, dry, 1, 1, 0, c_white, alpha);
    draw_sprite_ext(sCinemaRedblink, redLightFrm, drx + 9, dry + 16, 1, 1, 0, c_white, alpha);
    draw_sprite_ext(sCinemaGreenblink, greenLightFrm, drx + 6, dry + 31, 1, 1, 0, c_white, alpha);
    for (i = 0; i &lt; 9; i += 1)
    {
        draw_sprite_ext(sCinemaSwitch, swiSub[i], drx + swiX[i], dry + swiY[i], 1, 1, 0, c_white, alpha);
        draw_sprite_ext(sCinemaSwitchMeter, mtrSub[i], drx + mtrX[i], dry + mtrY[i], 1, 1, 0, c_white, alpha);
    }
    draw_sprite_ext(sCinemaHoopzHand, hndSub, drx + hndX, dry + hndY, 1, 1, 0, c_white, alpha);
}
else if (state == "pull")
{
    draw_sprite_ext(sCinemaHoopzPull, pulAni, drx, dry, 1, 1, 0, c_white, 1);
}
else if (state == "button")
{
    draw_sprite_ext(sCinemaFusionButton, 0, drx, dry, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sCinemaText, txtFrame, drx+36,dry, 1, 1, 0, c_white, 1)
    draw_sprite_ext(sCinemaButton, btnFrame, drx+61,dry+39, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sCinemaHoopzFist, 0, drx + fstX, dry + fstY, 1, 1, fstRot, c_white, 1);
}
else if (state == "buttonTransit")
{
    draw_sprite_ext(sCinemaButtonTransition, bTranAni, drx, dry, 1, 1, 0, c_white, 1);
}
else if (state == "map"|| state == "info")
{
    gridx += gridxspd*dt_sec();
    gridy += gridyspd*dt_sec();
    
    for(var ix = -12; ix&lt;192+12; ix+=12)
    {
        for(var iy=-12; iy&lt;120+12; iy+=12)
        {
            var _gridx = gridx mod 12;
            var _gridy = gridy mod 12;
            
            var leftEdge = 0;
            var topEdge = 0;
            var width = median(0,12,12 - (ix+_gridx+12-192));
            var height = median(0,12,12 - (iy+_gridy+12-120));
            if(ix + _gridx&lt;0){leftEdge = abs(ix+_gridx);}
            if(iy + _gridy&lt;0){topEdge = abs(iy+_gridy);}
            
            draw_sprite_part(sCinema_gridback,0,leftEdge,topEdge,width,height,x+leftEdge + ix + _gridx,y+topEdge+ iy + _gridy);
        }
    }

    // check at the very bottom of this script for more code
    // check at the very bottom of this script for more code
    // check at the very bottom of this script for more code
}
else if (state == "dna" || state == "final wait")
{
    cl0 = make_color_rgb(69, 17, 113);
    draw_rectangle_colour(drx, dry + dnaY + 160, drx + 192, dry + dnaY + 160 + 120, cl0, cl0, c_black, c_black, 0);
    draw_sprite_ext(sCinemaDNA, dnaSub, drx, dry + dnaY, 1, 1, 0, c_white, 1);
    
    // Dissolve
    dnaCou += dt_sec() * 240;
    while (dnaCou &gt; 0)
    {
        dnaCou -= 1;
        if (ds_list_size(dot0ds) &gt; 0 &amp;&amp; dnaTim &gt; 0.75) // DOT
        {
            val = ds_list_find_value(dot0ds, 0);
            xvl = val div 100;
            yvl = val mod 100;
            dotA[xvl, yvl] = 1;
            ds_list_delete(dot0ds, 0);
        }
        if (ds_list_size(dod0ds) &gt; 0 &amp;&amp; dnaTim &gt; 0.75) // DOD
        {
            val = ds_list_find_value(dod0ds, 0);
            xvl = val div 100;
            yvl = val mod 100;
            dodA[xvl, yvl] = 1;
            ds_list_delete(dod0ds, 0);
        }
    }
    
    // Point grid
    draw_sprite(spr_breedanm_gunpangrid, 2, drx + dnaGnx[0] - 8 -1, dry + dnaY + dnaGny[0] - 7 - 1);
    //spr = spr_samplegunsprites;
    //sub = Gunsmap("type to index", gun1[? "pType"]);
    gnx = drx + dnaGnx[0];
    gny = dry + dnaY + dnaGny[0];
    for (yyy = 0; yyy &lt; 24 / 2; yyy += 1)
    {
        for (xxx = 0; xxx &lt; 49 / 2; xxx += 1)
        {
            if (dotA[xxx, yyy] == 1)
            {
                dotSpd = 4;
                dis = point_distance(0, 0, dotXS[xxx, yyy], dotYS[xxx, yyy]);
                dotSpd -= dis / 20;
                dotX[xxx, yyy] = Goto(dotX[xxx, yyy], 24, dotXS[xxx, yyy] * (dt_sec() * dotSpd));
                dotY[xxx, yyy] = Goto(dotY[xxx, yyy], 28, dotYS[xxx, yyy] * (dt_sec() * dotSpd));
            }
            //draw_sprite_part_ext(spr, sub, xxx * 2, yyy * 2, 2, 2, gnx + dotX[xxx, yyy], gny + dotY[xxx, yyy], 1, 1, c_white, 1);
            HUD("gun draw part", gunSpr1, gunImg1, xxx * 2, yyy * 2, 2, 2, gnx + dotX[xxx, yyy], gny + dotY[xxx, yyy], 1, 1, c_white, 1);
        }
    }
    draw_sprite(sCinemaPanelGun, 0, drx + dnaGnx[0] - 11 - 2, dry + dnaY + dnaGnx[0] - 11 - 3);
    
    // POINT GRID 2
    draw_sprite(spr_breedanm_gunpangrid, 2, drx + dnaGnx[1] - 7, dry + dnaY + dnaGny[1] - 6);
    //spr = spr_samplegunsprites;
    //sub = Gunsmap("type to index", gun2[? "pType"]);
    gnx = drx + dnaGnx[1];
    gny = dry + dnaY + dnaGny[1];
    for (yyy = 0; yyy &lt; 24 / 2; yyy += 1)
    {
        for (xxx = 0; xxx &lt; 49 / 2; xxx += 1)
        {
            if (dodA[xxx, yyy] == 1)
            {
                dotSpd = 4;
                dis = point_distance(0, 0, dodXS[xxx, yyy], dodYS[xxx, yyy]);
                dotSpd -= dis / 20;
                dodX[xxx, yyy] = Goto(dodX[xxx, yyy], 26, dodXS[xxx, yyy] * (dt_sec() * dotSpd));
                dodY[xxx, yyy] = Goto(dodY[xxx, yyy], -6, dodYS[xxx, yyy] * (dt_sec() * dotSpd));
            }
            //draw_sprite_part_ext(spr, sub, xxx * 2, yyy * 2, 2, 2, gnx + dodX[xxx, yyy], gny + dodY[xxx, yyy], 1, 1, c_white, 1);
            HUD("gun draw part", gunSpr2, gunImg2, xxx * 2, yyy * 2, 2, 2, gnx + dodX[xxx, yyy], gny + dodY[xxx, yyy], 1, 1, c_white, 1);
        }
    }
    draw_sprite(sCinemaPanelGun, 1, drx + dnaGnx[1] - 11 + 2 - 8 + 2, dry + dnaY + dnaGny[1] - 11 + 1 - 3 + 2);//11 + 2 - 46 + 2);
    
    // Bottom
    draw_sprite_ext(sCinemaPumpBox, dnaPmp, drx, dry + 159 + dnaY, 1, 1, 0, c_white, 1);
    draw_sprite_ext(sCinemaPumpInside, 0, drx + 61, dry + 159 + dnaY + 7, 1, 1, 0, c_white, 1);
    pmx = drx + 61; 
    pmy = dry + 159 + dnaY + 9;
    rev = abs(dnaOpn - 39);
    HUD("gun draw", gunSpr3, gunImg3, pmx + 9, pmy + 6, 1, 1, c_white, 1);
    HUD("gun draw", gunSpr3, gunImg3, pmx + 9, pmy + 6, 1, 1, c_black, dnaAlp);
    //draw_sprite_ext(spr_samplegunsprites, Gunsmap("type to index", gun1[? "pType"]), pmx + 9, pmy + 6, 1, 1, 0, c_white, 1);
    //draw_sprite_ext(spr_samplegunsprites, Gunsmap("type to index", gun1[? "pType"]), pmx + 9, pmy + 6, 1, 1, 0, c_black, dnaAlp);
    d3d_set_fog(true, c_white, 0, 0);
    //draw_sprite_ext(spr_samplegunsprites, Gunsmap("type to index", gun1[? "pType"]), pmx + 9, pmy + 6, 1, 1, 0, c_white, dnaGunAlp);
    HUD("gun draw", gunSpr3, gunImg3, pmx + 9, pmy + 6, 1, 1, c_white, dnaGunAlp);
    d3d_set_fog(false, c_white, 0, 0);
    
    draw_sprite_ext(sCinemaPumpInside, 4, pmx, pmy - 2, 1, 1, 0, c_white, dnaAlp);
    HUD("gun draw", gunSpr3, gunImg3, pmx + 9, pmy + 6, 1, 1, c_black, dnaAlp);
    //draw_sprite_ext(spr_samplegunsprites, Gunsmap("type to index", gun1[? "pType"]), pmx + 9, pmy + 6, 1, 1, 0, c_black, dnaAlp);
    draw_sprite_part_ext(sCinemaPumpInside, 2, 0, rev, 70, 39 - rev, pmx, pmy, 1, 1, c_white, 1);
    draw_sprite_part_ext(sCinemaPumpInside, 3, 0, 0, 70, 39 - rev, pmx, pmy + rev - 4, 1, 1, c_white, 1);
    
    // Smoke
    rev /= 39;
    pmy += 20;
    //70 x
    /////////if (rev &gt; 0.8) dnaSmk += dt_sec() * (1 + (rev));
    if (rev &gt; 0.6) dnaSmk += dt_sec() * (0.75);
    if (dnaAlp &lt; 1) dnaSmk += dt_sec() * (0.75);
    if (dnaGunAlp &lt; 1) dnaSmk += dt_sec() * (0.75);
    if (dnaY == -160) 
    {
        dnaSmkCou += dt_sec() * (1 + (rev));
        if (rev != 0 &amp;&amp; rev &lt; 0.2) dnaSmkCou += dt_sec() * 3;
    }
    while (dnaSmkCou &gt; dnaSmk)
    {
        dnaSmkCou -= dnaSmk;
        xrn = random(70);
        yrn = - (rev * 25) + random(rev * 50);
        var smkObj = instance_create(pmx + xrn, pmy + yrn, oSmoke);
        //with (smkObj) event_user(0);
        Destroy(smkObj);
    }
    
    //
    pmx = drx + 13; pmy = dry + 160 + 89 + dnaY;
    dnaInfAlp = abs(dnaGunAlp - 1);
    draw_sprite_ext(spr_breedanm_typepan_text, 20, pmx, pmy - 30, 1, 1, 0, c_white, dnaInfAlp);
    draw_sprite_ext(spr_breedanm_typepan_type, Gunsmap("type to index", gun3[? "pType"]), pmx, pmy, 1, 1, 0, c_white, dnaInfAlp); //dnaGunAlp);
    /// DNA
    draw_set_alpha(dnaInfAlp);
    CinemaFusion("draw dna", pmx + 40, pmy - 30, gun3[? "pAffix"], 2);
    CinemaFusion("draw speed", pmx + 40 + 34, pmy - 31, gun3[? "pFireSpeed"]);
    CinemaFusion("draw firepower", pmx + 40 + 34, pmy + 25, gun3[? "pDamageMin"], gun3[? "pDamageRand"], 2);
    CinemaFusion("draw ammo", pmx + 40 + 34 + 53, pmy - 31, gun3[? "pType"], gun3[? "pMaxAmmo"]);
    draw_set_alpha(1);
}

////////////////////////////////////////////// FLASH
if (flashAlpha &gt; 0)
{
    draw_sprite_ext(s1x1, 0, drx, dry, 192, 120, 0, flashColor, flashAlpha);
    flashAlpha -= dt_sec() / flashSpeed;
}

if (state != "final fade")
{
    draw_set_color(c_black);
    scr_drawRect(drx, dry, drx + 192, dry - 100, 0);
    scr_drawRect(drx, dry + 120, drx + 192, dry + 120 + 180, 0);
    scr_drawRect(drx, dry - 120, drx - 192, dry + 120 + 120, 0);
    scr_drawRect(drx + 192, dry - 120, drx + 192 + 192, dry + 120 + 120, 0); // right
}

if (state == "map")
{
    //drx //-= 60;
    ///dry -= 20;
    drx = x; dry = y;
    
    if(!surface_exists(gunsurface)){gunsurface = surface_create(160,160);}
    
    surface_set_target(gunsurface);
        draw_set_color(c_white);
        Gunsmap("draw", 0, 0, 2); //, Gunsmap("type to index", gunTop), gunTopSel, Gunsmap("type to index", gunBot), gunBotSel);
        // other
        mapSpc = 45;
        mapGunX = 60;
        //if (mapBasicSprite == 1) spr = spr_breedanm_typepan_type; else spr = spr_breedanm_typepan_type;
    
        // Line progress
        gpl = point_distance(gunTopX, gunTopY, gunMrgX, gunMrgY);
        gpd = point_direction(gunTopX, gunTopY, gunMrgX, gunMrgY);
        draw_sprite_ext(s1x1, 0, gunTopX - 1, gunTopY, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunTopX + 1, gunTopY, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunTopX, gunTopY + 1, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunTopX, gunTopY - 1, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunTopX, gunTopY, gpl * mapPro, 1, gpd, c_white, 1);
        gpl = point_distance(gunBotX, gunBotY, gunMrgX, gunMrgY);
        gpd = point_direction(gunBotX, gunBotY, gunMrgX, gunMrgY);
        draw_sprite_ext(s1x1, 0, gunBotX - 1, gunBotY, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunBotX + 1, gunBotY, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunBotX, gunBotY - 1, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunBotX, gunBotY + 1, gpl * mapPro, 1, gpd, c_black, 1);
        draw_sprite_ext(s1x1, 0, gunBotX, gunBotY, gpl * mapPro, 1, gpd, c_white, 1);
        
        draw_sprite_ext(sMenuUtilityGunMapMarker, 0, gunTopX, gunTopY, 1, 1, 0, c_white, mapAl0);
        draw_sprite_ext(sMenuUtilityGunMapMarker, 1, gunBotX, gunBotY, 1, 1, 0, c_white, mapAl1);
        if (mapState == 5) 
        {
            draw_sprite_ext(sMenuUtilityGunMapMarker, 2, gunMrgX, gunMrgY, 1, 1, mapRot, c_white, 1);
        }
        
    surface_reset_target();
    
    draw_surface_part_ext(gunsurface,surFocusX-40/surZoom,surFocusY-40/surZoom,80/surZoom,80/surZoom,drx+16,dry+20,surZoom,surZoom,c_white,mapAlphaGlob);
    draw_set_alpha(mapAlphaGlob);
    scr_drawRect(drx+16-2,dry+20-2, drx + 16 +80+2, dry+20 + 80+2, 1);
    
    // Gunspower meter
    mtrX = drx + mapGunX + 60 + 20;
    mtrY = dry + 50 + 12;
    draw_set_color(c_white);
    scr_drawRect(mtrX - 4, mtrY - 30, mtrX + 4, mtrY + 30, 1);
    if (mapState == 1) gunScaleY = Goto(gunScaleY, 0, (abs(gunScaleY - 0) * 2) * dt_sec());
    if (mapState &gt;= 2) gunScaleY = Goto(gunScaleY, gunPow, (abs(gunScaleY - 0) * 2) * dt_sec());
    mtrY += -30 + (60 * gunScaleY);
    scr_drawRect(mtrX - 8, mtrY - 4, mtrX + 8, mtrY + 4, 0);
    // GUN TOP DRAW
    
    HUD("gun draw", gunSpr1, gunImg1, drx + 55 + mapGunX, dry + 40 + 10 - mapSpc, 1, 1, c_white, mapAl0);
    
    //draw_sprite_ext(sMenuUtilityGunMapMarker, 0, drx + gunTopX, dry + gunTopY, 1, 1, 0, c_white, mapAl0);
    // GUN BOTTOM DRAW
    HUD("gun draw", gunSpr2, gunImg2, drx + 55 + mapGunX, dry + 40 + 10 + mapSpc, 1, 1, c_white, mapAl1);
    
    //draw_sprite_ext(sMenuUtilityGunMapMarker, 1, drx + gunBotX, dry + gunBotY, 1, 1, 0, c_white, mapAl1);
    draw_set_alpha(1);
}
//draw_sprite_ext(sMenuUtility, 0, 0, 0, 1, 1, 0, c_white, 0.5);
if (fadeExit &gt; 0) 
{
    draw_sprite_ext(s1x1, 0, vrx, vry, 640, 480, 0, c_black, fadeExit);
    pmx = drx + 61 + 9; 
    pmy = dry + 159 + dnaY + 9 + 6;
    dsx = vrx + 19;
    dsy = vry + 111;
    acx = (pmx * abs(gunShift - 1)) + (dsx * gunShift);
    acy = (pmy * abs(gunShift - 1)) + (dsy * gunShift);
    acs = 1 + gunShift;
    HUD("gun draw", gunSpr3, gunImg3, acx, acy, acs, acs, c_white, min(1, gunFinal * 2));
    Utility("alpha", gunShiftWait);
    gunSel = global.fuseGunSel;
    Utility("draw guns info", 0, 0, 0, 0);
    Utility("alpha", 1);
    Utility("alpha", gunTextWait * fadeDarling);
    Utility("text 1b", 160, +26, darling, 1, 1, 0); // drx + 65 - 48
    Utility("alpha", 1);
}
//if (fadeDestroy &gt; 0) draw_sprite_ext(s1x1, 0, vrx, vry, 640, 480, 0, c_black, fadeDestroy);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="16">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Map guns
gunPow = 50;

gunBot = gun1[? "pType"];
gunBotSel = Gunsmap("get dot", Gunsmap("type to index", gunBot));

gunTop = gun2[? "pType"];
gunTopSel = Gunsmap("get dot", Gunsmap("type to index", gunTop));

gunTopX = Gunsmap("x", Gunsmap("type to index", gunTop), gunTopSel) * gunsmapScale;
gunTopY = Gunsmap("y", Gunsmap("type to index", gunTop), gunTopSel) * gunsmapScale;
gunBotX = Gunsmap("x", Gunsmap("type to index", gunBot), gunBotSel) * gunsmapScale;
gunBotY = Gunsmap("y", Gunsmap("type to index", gunBot), gunBotSel) * gunsmapScale;

gunBotPow = random(1);
gunTopPow = random(1);
gunPow = (gunBotPow + gunTopPow) / 2;

dfx = (gunBotX - gunTopX);// / 100;
dfy = (gunBotY - gunTopY);// / 100;

gunMrgX = gunTopX + (dfx * gunPow);
gunMrgY = gunTopY + (dfy * gunPow);

gunScaleY = 0.5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="15">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create point array for guns
executeSkip = 1;
dotDiv = 2;
ycc = 0;
xcc = 0;
dot0ds = ds_list_create();
dod0ds = ds_list_create();
for (yyy = 0; yyy &lt; 24; yyy += 2)
{
    for (xxx = 0; xxx &lt; 49; xxx += 2)
    {
        dotX[xcc, ycc] = xxx;
        dotY[xcc, ycc] = yyy;
        dotXS[xcc, ycc] = abs(xxx - 24);
        dotYS[xcc, ycc] = abs(yyy - 28);
        dotA[xcc, ycc] = 0;
        ds_list_add(dot0ds, (xcc * 100) + ycc);
        //
        dodX[xcc, ycc] = xxx;
        dodY[xcc, ycc] = yyy;
        dodXS[xcc, ycc] = abs(xxx - 24);
        dodYS[xcc, ycc] = point_distance(0, yyy, 0, -6);
        dodA[xcc, ycc] = 0;
        ds_list_add(dod0ds, (xcc * 100) + ycc);
        xcc += 1;
    }
    xcc = 0;
    ycc += 1;
}
ds_list_shuffle(dot0ds);
ds_list_shuffle(dod0ds);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gun info
with(obj_breedanm_parentpanels){instance_destroy();}

var ob = instance_create(x, y, obj_breedanm_parentpanels);
ob.gun1 = gun1;
ob.gun2 = gun2;

with(ob){event_user(0);}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Switch Flick Step
if (hndAct)
{
    if (hndTim == 0) audio_play_sound_ext(soundSwitchBackground, 10, 0);
    hndTim += dt_sec();
    hndTar = clamp(hndTar, 0, 9);
    dsx = swiX[hndTar] - 10;
    dsy = swiY[hndTar] + 1 - 8; //-10 is for push
    
    greenLightFrm = (greenLightFrm + 8*dt_sec()) mod 4;
    if(hndTar&gt;4){redLightFrm = (redLightFrm + 8*dt_sec()) mod 4;}

    if (hndStt == 0 &amp;&amp; hndCou == 0 &amp;&amp; (hndX != dsx || hndY != dsy))
    {
        hndMom += hndAcc * dt_sec();
        hndMom = clamp(hndMom, 0, switchHandSpeed);
        hndSpd += hndMom;
        hndX = Goto(hndX, dsx, hndSpd * dt_sec());
        hndY = Goto(hndY, dsy, hndSpd * dt_sec());
    }
    else
    {
        if (hndTar &lt; 9)
        {
            hndMom -= ((hndAcc * dt_sec()) / 2);
            hndMom = clamp(hndMom, 0, switchHandSpeed);
            if (hndStt == 0)
            {
                hndY = Goto(hndY, dsy + 8, hndSpd * dt_sec());
                hndCou += dt_sec();
                if (hndCou &gt; hndWa0) { hndStt += 1; hndSub = 1; hndCou = 0; mtrSub[hndTar] = 1; swiSub[hndTar] = 0; }
            }
            else if (hndStt == 1)
            {
                if (hndCou == 0) audio_play_sound_ext(soundSwitch, 10, 0);
                hndCou += dt_sec();
                if (hndCou &gt; hndWa1) { hndStt += 1; hndSub = 1; hndCou = 0; }
            }
            else if (hndStt == 2)
            {
                hndCou += dt_sec();
                if (hndCou &gt; hndWa2) 
                { 
                    hndStt = 0; 
                    hndSub = 2; 
                    hndCou = 0; 
                    while (swiSub[hndTar] == 0) hndTar += 1; 
                }
            }
        }
        else // Go to pull
        {
            show_debug_message("Time for SWITCH: " + string(hndTim * 1000) + "ms.");
            state = "pull";
        }
    }
}

// Draw meters
ext = 0;
for (i = 0; i &lt; 9; i += 1) { if (swiSub[i] == 0) ext += 1; }
for (i = 0; i &lt; 9; i += 1) 
{
    if (swiSub[i] == 0)
    {
        mtrSub[i] += (mtrSub[i] * 3) * dt_sec();
        mtrSub[i] = clamp(mtrSub[i], 0, 11 - 9 + ext);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
