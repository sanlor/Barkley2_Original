<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_hugebrainalien</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>o_enemygroup_catfish</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////you get all the default variables from EnemyCombatActor
event_inherited();

// Enemy stats
scr_enemyDB_statsGet(enemyBuild);

// Enemy configurations
scr_entity_setZHitbox(0, 64);
shield_equipped = false;

count = 0;
deathSound = "catfishsmall_death";
damageSound = "catfishsmall_grunt";
atkprog = 0;
atkdoin = 0;

var conf, attacks, attack, guard;

///setup passive and active AIs
scr_AI_addPassiveState(scr_AI_passive_none);
scr_AI_addActiveState(scr_AI_active_noAI);

/////////////////////setup AI Switch and attacks
conf = scr_AI_setSwitch(scr_AI_switch_conditions);
ds_map_replace(conf,"attackInterval",15); ///added interval between every attack
attacks = ds_map_find_value(conf, "attacks");

////SMALL SPARKS
///first configure the attack itself
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Small Spark");
ds_map_replace(conf, "beforeTime", 6);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 3);
///then configure the AI switch's decision-making process for when to use that attack
///Attack can be performed at all times, and can be repeated, but has low priority. "fall-back" attack.
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 3); ///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);

////BIG SPARK
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Big Spark");
ds_map_replace(conf, "beforeTime", 12);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 5);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed when target is in the center of the map
ds_map_add(attack, "noRepeat", true);

///BUBBLES
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Bubbles");
ds_map_replace(conf, "beforeTime", 4);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 2);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10); ///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack is performed if target is not too close or too far
ds_map_add(attack, "distMin", 64);
ds_map_add(attack, "distMax", 200);
ds_map_add(attack, "noRepeat", true);

///BEAM
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Beam");
ds_map_replace(conf, "beforeTime", 16);
ds_map_replace(conf, "damageTime", 2);
ds_map_replace(conf, "afterTime", 4);
beamAttack = ds_map_create(); ///gving it its own name so I can refer to it later to enable it manually.
ds_map_add(beamAttack, "action", scr_AI_action_userEvent);
ds_map_add(beamAttack, "attackPriority", 25);
ds_map_add(beamAttack, "actionMap", conf);
ds_list_add(attacks, beamAttack);
///Attack is initially disabled.
///It is enabled once you have killed all of the queens' main guard
///and then only when you are in the center of the map at a certain distance
ds_map_add(beamAttack, "distMin", 128);
ds_map_add(beamAttack, "needState", "center");
ds_map_add(beamAttack, "noRepeat", true);
//ds_map_add(beamAttack, "disabled", true);

////LEFT SWIPE
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "LeftSwipe");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed whenever target is nearby and to the left
ds_map_add(attack, "needState", "left");
ds_map_add(attack, "noRepeat", true);

////RIGHT SWIPE
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "RightSwipe");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10); //Medium chance
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed whenever target is nearby and to the right
ds_map_add(attack, "needState", "right");
ds_map_add(attack, "noRepeat", true);

////LEFT TAIL WHACK
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "TailLeft");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 1);

attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 40); //Very high chance
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed whenever target is in the back of the room, to the left. Very high likelihood.
ds_map_add(attack, "needState", "backLeft");

////RIGHT TAIL WHACK
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "TailRight");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 40); //Very high chance
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed whenever target is in the back of the room, and to the right.
ds_map_add(attack, "needState", "backRight");


////DOUBLE SWIPE
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "DoubleSwipe");
ds_map_replace(conf, "beforeTime", 5);
ds_map_replace(conf, "damageTime", 0.5);
ds_map_replace(conf, "afterTime", 2);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 30); //Medium-high chance to pick
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed whenever target is nearby and in the center. Medium-high likelihood
ds_map_add(attack, "needState", "center");
ds_map_add(attack, "distMax", 96);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

count +=1;

if(count &gt;10)
{
    if(I_AI_target!=noone &amp;&amp; instance_exists(I_AI_target))
    {
        //ai_curState
        if(I_AI_target.y &lt; 80)
        {
            if(I_AI_target.x&lt;192){ai_curState="backLeft";}
            else{ai_curState = "backRight";}
        }
        else
        {
            if(I_AI_target.x&lt;144){ai_curState = "left";}
            else if(I_AI_target.x&gt;240){ai_curState = "right";}
            else{ai_curState = "center";}
        }
    }
    
    if(instance_exists(o_enemy_catfish_mounted) || instance_exists(o_enemy_catfish_shield))
    {ds_map_replace(beamAttack, "disabled", true);}else{ds_map_replace(beamAttack, "disabled", false);}
    
    show_debug_message(ai_curState);
    count = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////THIS HANDLES ALL OF OOZES' ATTACK ACTIONS:
switch(a_attackState)
{
    case "reset": ///reset attack actions' timing vars
        I_atk_evnt_intBefore = ds_map_find_value(conf, "beforeTime");
        I_atk_evnt_intDamage = ds_map_find_value(conf, "damageTime");
        I_atk_evnt_intAfter = ds_map_find_value(conf, "afterTime");
        I_atk_evnt_didAttack = false;
        a_attackAnim = 0;
        a_attackState = "before";
        a_attackSubState = 0;
        scr_entity_setMoveXY(0, 0);
        break;
        
    case "before": ///timing before any attack anim
        if(a_attackAnim&lt;I_atk_evnt_intBefore)
        {
            a_attackAnim+= dt();
        }
        else
        {
            a_attackAnim = 0;
            a_attackState = "damage";
            spawnAtkObj = true;
        }
        atkdoin = 0;
        break;
        
    case "damage": ///action itself
        a_attackState = "after";
        switch(a_attackName)
        {
            case "Small Spark":
                ob = instance_create(x+64,y+16,o_enemyAttack_bulletNormal);
                ob.life = 60;
                ob.sprite_index = s_catfish_atk_spark;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 20);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 5);
                with ob scr_entity_setDirSpd(point_direction(x,y,other.I_AI_target.x,other.I_AI_target.y),5);
                ob.dmg_dir = ob.direction;
                ds_list_copy(ob.target_list, target_list);
                
                ob = instance_create(x-64,y+16,o_enemyAttack_bulletNormal);
                ob.life = 60;
                ob.sprite_index = s_catfish_atk_spark;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 20);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 5);
                with ob scr_entity_setDirSpd(point_direction(x,y,other.I_AI_target.x,other.I_AI_target.y),5);
                ob.dmg_dir = ob.direction;
                ds_list_copy(ob.target_list, target_list);
                break;
            case "Big Spark":
                ob = instance_create(x,y+48,o_enemyAttack_bulletNormal);
                ob.life = 120;
                ob.sprite_index = s_catfish_atk_bigspark;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 50);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 20);
                with ob scr_entity_setDirSpd(point_direction(x,y,other.I_AI_target.x,other.I_AI_target.y),3);
                ob.dmg_dir = ob.direction;
                ds_list_copy(ob.target_list, target_list);
                break;
                
            case "Bubbles":
                a_attackAnim+=dt();
                if(a_attackAnim&gt;5)
                {
                    a_attackAnim = 0;
                    atkdoin+=1;
                    ob = instance_create(x,y+32,o_enemy_catfish_bubble);
                    ob.direction = point_direction(x,y,other.I_AI_target.x,other.I_AI_target.y)-20+atkdoin*5;
                }
                if(atkdoin&lt;5)
                {
                    a_attackState = "damage";
                }
                break;
                
            case "Beam":
                ob = instance_create(x,y+48,o_enemyAttack_bulletNormal);
                ob.life = 20;
                ob.sprite_index = s_catfish_queen_beam;
                ob.image_yscale = 10;
                ob.dmg_dir = 270;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 60);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 20);
                ds_list_copy(ob.target_list, target_list);
                break;
                
            case "LeftSwipe":
                ob = instance_create(x-48,y+52,o_enemyAttack_bulletNormal);
                ob.life = 3;
                ob.sprite_index = s_catfish_atk_swipe;
                ob.image_xscale = 1;
                ob.dmg_dir = 360-20;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 40);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 10);
                ds_list_copy(ob.target_list, target_list);
                break;
            case "RightSwipe":
                ob = instance_create(x+48,y+52,o_enemyAttack_bulletNormal);
                ob.life = 3;
                ob.sprite_index = s_catfish_atk_swipe;
                ob.image_xscale = -1;
                ob.dmg_dir = 180+20;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 40);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 10);
                ds_list_copy(ob.target_list, target_list);
                break;
            case "DoubleSwipe":
                ob = instance_create(x-48,y+52,o_enemyAttack_bulletNormal);
                ob.life = 3;
                ob.sprite_index = s_catfish_atk_swipe;
                ob.image_xscale = 1;
                ob.dmg_dir = 270;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 40);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 10);
                ds_list_copy(ob.target_list, target_list);
                
                ob = instance_create(x+48,y+52,o_enemyAttack_bulletNormal);
                ob.life = 3;
                ob.sprite_index = s_catfish_atk_swipe;
                ob.image_xscale = -1;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 40);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 10);
                ds_list_copy(ob.target_list, target_list);
                break;
                
            case "TailLeft":
                ob = instance_create(x-48,y,o_enemyAttack_bulletNormal);
                ob.life = 3;
                ob.sprite_index = s_catfish_atk_swipe;
                ob.image_xscale = 1;
                ob.image_yscale = -1;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 40);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 10);
                ds_list_copy(ob.target_list, target_list);
                break;
                
            case "TailRight":
                ob = instance_create(x+48,y,o_enemyAttack_bulletNormal);
                ob.life = 3;
                ob.sprite_index = s_catfish_atk_swipe;
                ob.image_xscale = -1;
                ob.image_yscale = -1;
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 40);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 10);
                ds_list_copy(ob.target_list, target_list);
                break;
        }
        
        break;
        
    case "after": ///timing after attack anim
        if (a_attackAnim &lt; I_atk_evnt_intAfter)
        {
            a_attackAnim += dt();
        }
        else
        {
            a_attackState = "reset";
            stateResult = AI_STATERESULT_REMOVE;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
draw_sprite_ext(sprite_index,0,dx,dy,1,1,0,c_white,1);
scr_artDebugPlaceholder();

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>80,77</point>
    <point>80,80</point>
  </PhysicsShapePoints>
</object>
