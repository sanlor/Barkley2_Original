<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>icon_parent</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Actor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create

/// scr_event_interactive_init()
/// Automatically called by the InteractiveActor upon creation.

event_inherited();

_state = 0;
_variables = ds_map_create();
_started = false;
_autoDraw = true;
_selectedOutline = false;
_disableOutline = false;
_active = true;
_pedestrian = false;
_duergar = false; // For draw, but can be used for other things later

// True if you can interact with this event.
_interactive = true;
_interactive_timer = 0;
_interactive_distance = global.settingInteractiveDistance; // GZ: The max distance you can be to click this

// True if the sprite is using automatic animations (like when it is moving), or false otherwise.
_automatic_animation = false;
// The animation to use if automatic animation isn't true. 
_current_animation = ANIMATION_DEFAULT;
scr_entity_animation_setSpriteIndex(ANIMATION_DEFAULT, sprite_index);
scr_entity_animation_setSpeed(ANIMATION_DEFAULT, ANIMATION_DEFAULT_SPEED);
scr_entity_set_walk(sprite_index, sprite_index, sprite_index, sprite_index, sprite_index, sprite_index, sprite_index, sprite_index);

// GZ NOTE: Added exception variable so you can do special things with hard coded objects
_exception = 0;

// The last direction this actor was in.
_last_direction = RIGHT;
_last_frame = 0; // For draw event

// Used for camera following.
camera_target_x = x;
camera_target_y = y;
camera_speed = 32;

// Walk animation constants
walk_animation[0] = ANIMATION_EAST;
walk_animation[1] = ANIMATION_NORTHEAST;
walk_animation[2] = ANIMATION_NORTH;
walk_animation[3] = ANIMATION_NORTHWEST;
walk_animation[4] = ANIMATION_WEST;
walk_animation[5] = ANIMATION_SOUTHWEST;
walk_animation[6] = ANIMATION_SOUTH;
walk_animation[7] = ANIMATION_SOUTHEAST;

// Edit for strips
sprite_width_edit = sprite_width;
sprite_height_edit = sprite_height;

// InteractiveActors are rigid by default
scr_actor_setRigid(id)

// Specify defaults for all of the Event Hooks
scr_event_hook_onStart(NULL);
scr_event_hook_onInteract(NULL);
scr_event_hook_onCollision(NULL);

script_start = "";
xFlip = 0; // Only used for Thrax scene, can be used to override image_xscale
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Step

/// scr_event_interactive_step()
/// Automatically called by the InteractiveActor when stepping.

if(_active) {
    event_inherited();
}
if paused() exit;

global.eventObject = id;

// == EVENT HOOK: START ==
if (!_started) {
    // Execute start events on the first step only
    _started = true;
    
    
    if (hook_onStart_script != -1) {
        
        script_execute(hook_onStart_script, SCRIPT_START);
    }
}

// == EVENT HOOK: INTERACTIVE ==
// If an event has just ended, this actor is inactive for a small period of time.
// Interactive hook actually called in scr_player_stance_standard.
if (!_interactive and _interactive_timer &gt; 0) {
    _interactive_timer--;
    if (_interactive_timer &lt;= 0) {
        _interactive = true;
    }
}

// Update camera targets incase a camera is following this actor.
camera_target_x = x;
camera_target_y = y;

// Sets the direction of this actor.
if (delta_x != 0 or delta_y != 0) {
    if (abs(delta_x) &gt; abs(delta_y)) {
        if (delta_x &gt;= 0) {
            _last_direction = RIGHT;
        } else {
            _last_direction = LEFT;
        }
    } else {
        if (delta_y &gt;= 0) {
            _last_direction = DOWN;
        } else {
            _last_direction = UP;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="o_hoopz">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// scr_event_interactive_collision_hoopz()
/// Called automatically when the interactive actor collides with hoopz.

// == EVENT HOOK: COLLIDE WITH HOOPZ ==
global.eventObject = id;
global.eventInteract = false;
global.eventFacing = o_hoopz.facing;

if (hook_onCollision_hoopz_script != -1) {
    script_execute(hook_onCollision_hoopz_script, SCRIPT_COLLISION_HOOPZ);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw
/// scr_event_interactive_draw()

if (!_active) exit;

event_inherited();

// Updates the animation based off of movement and direction.
var current_animation = NULL;
if (_automatic_animation) {
    if (delta_x != 0 or delta_y != 0) {
        var dirWlk = round(point_direction(0, 0, delta_x, delta_y) / 45);
        if (dirWlk &gt;= 8) dirWlk = 0;
        if (walkBackwards == 1) { dirWlk -= 4; if (dirWlk &lt; 0) dirWlk += 8; }
        if (_pedestrian)  // isPED
        {
            current_animation = walk_animation[dirWlk];
            image_xscale = 1;
            if (dirWlk == 3 || dirWlk == 4 || dirWlk == 5) image_xscale = -1;
        }
        else if (flipAuto == 0)
        {
            current_animation = walk_animation[dirWlk];
        }
        else
        {
            if (dirWlk == 0 || dirWlk == 1 || dirWlk == 2 || dirWlk == 7) image_xscale = 1;
            else image_xscale = -1;
            if (xFlip != 0) image_xscale = xFlip;
            if (dirWlk == 1 || dirWlk == 2 || dirWlk == 3) current_animation = walk_animation[1];
            else current_animation = walk_animation[7];
        }
    } else {
        switch(_last_direction) {
            case RIGHT:
                current_animation = ANIMATION_IDLE_RIGHT;
                break;
            case LEFT:
                current_animation = ANIMATION_IDLE_LEFT;
                break;
            case DOWN:
                current_animation = ANIMATION_IDLE_DOWN;
                break;
            case UP:
                current_animation = ANIMATION_IDLE_UP;
                break;
        }
    }
} else {
    current_animation = _current_animation;
}

if (!scr_entity_animation_exists(current_animation)) {
    current_animation = ANIMATION_DEFAULT;
}

var frame = scr_entity_animation_getImage(current_animation);
_last_frame = frame;
var sprite = scr_entity_animation_getSpriteIndex(current_animation);
if (sprite == NULL) {
    sprite = sprite_index;
}

// Draw white outline
if (_duergar) scrExe = DrawSpriteExt; else scrExe = DrawStrip;
if (_selectedOutline &amp;&amp; sprite_exists(sprite_index) &amp;&amp; _disableOutline = false) {
    if _pedestrian = true then 
    {
        /*d3d_set_fog(true, make_color_rgb(80, 210, 255), 0, 0);    
        script_execute(scrExe, sprite, frame, dx-1+ pushed_x, dy+ pushed_y, image_xscale, image_yscale, image_blend, alpha);
        script_execute(scrExe, sprite, frame, dx+1+ pushed_x, dy+ pushed_y, image_xscale, image_yscale, image_blend, alpha);
        script_execute(scrExe, sprite, frame, dx+ pushed_x, dy-1+ pushed_y, image_xscale, image_yscale, image_blend, alpha);
        script_execute(scrExe, sprite, frame, dx+ pushed_x, dy+1+ pushed_y, image_xscale, image_yscale, image_blend, alpha);
        d3d_set_fog(false, 0, 0, 0);*/
    }
    else 
        {
        d3d_set_fog(true, c_white, 0, 0);
        draw_sprite_ext(sprite, frame, dx-1, dy, image_xscale, image_yscale, image_angle, image_blend, image_alpha);
        draw_sprite_ext(sprite, frame, dx+1, dy, image_xscale, image_yscale, image_angle, image_blend, image_alpha);
        draw_sprite_ext(sprite, frame, dx, dy-1, image_xscale, image_yscale, image_angle, image_blend, image_alpha);
        draw_sprite_ext(sprite, frame, dx, dy+1, image_xscale, image_yscale, image_angle, image_blend, image_alpha);
        d3d_set_fog(false, 0, 0, 0);
        }
    
    _selectedOutline = false; // Player object must keep outline active each frame
}

// Draw sprite
if _pedestrian = true then script_execute(scrExe, sprite, frame, dx + pushed_x, dy + pushed_y, image_xscale, image_yscale, image_blend, alpha); 
else draw_sprite_ext(sprite, frame, dx, dy, image_xscale, image_yscale, 0, image_blend, image_alpha);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
