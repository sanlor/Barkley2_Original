<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_skullpep</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>EnemyCombatActor</parentName>
  <maskName>mask_rect_16by16</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create
event_inherited();

if (instance_exists(o_room_darkarea))
{
    light = Light("add", id, 64, .2, merge_color(c_aqua, c_black, 0.66));
}
else light = -999;

bob = 0; // bobbing up and down
zht = 16; // z to be in air

smkSec = 6; // How many smokes to create in a second
smkCou = 0; // Do not touch
smkCol[0] = make_color_rgb(0, 154, 255);
smkCol[1] = make_color_rgb(142, 180, 198);
smkCol[2] = make_color_rgb(192, 218, 255);

proSec = 0.2; // Projectiles a second
proCou = 0;
proDmg = 5;

// Enemy stats
scr_enemyDB_statsGet(enemyBuild);
scr_entity_setCollisionType(COLLISION_ALL);
scr_path_setMovementType(scr_path_movementType_thrusters);
scr_path_setLookaheadDist(20);
scr_stats_knockback_setKnockbackHandler(scr_stats_knockbackHandler_teleport);
scr_AI_aggro_configure(120, 200, 800);
scr_entity_setZHitbox(0, 24 + 4);

deathSound = "cGremlinSmall_death";
damageSound = "cGremlinSmall_grunt";

var conf, attacks, attack, guard;
guard = scr_AI_addPassiveState(scr_AI_passive_proximity);
guard[? "sndAlertSound"] = "cGremlinSmall_alert";

//scr_AI_addActiveState(scr_AI_active_approach);
var active = scr_AI_addActiveState(scr_AI_active_approach_thrusters);
active[? "thrustStr"] = 0.75 / 2;//1.6
active[? "friction"] = .2 * 1;//35
active[? "maxSpeed"] = 8 / 2;//25
active[? "maxSpeedPath"] = 8 / 2;//12
active[? "targetDeviate"] = 128;

//activeHangback = scr_AI_addActiveState(scr_AI_active_hangback);
//activeHangback[? "switchPriority"] = 10;
//activeHangback[? "switchRemoveMaxDist"] = 120;
//activeHangback[? "switchAddMaxDist"] = 80;

// Create and configure AI switch
var attack, action;
conf = scr_AI_setSwitch(scr_AI_switch_standard);

// Shot
var shot = scr_AI_addAction(scr_AI_action_shot);
//shot[? "burst"] = 1;
//shot[? "burstRnd"] = 1;
//shot[? "gunRange"] = 100;
shot[? "beforeTime"] = 0;
shot[? "afterTime"] = 0;
shot[? "aim"] = 0;
shot[? "trackingSpd"] = 360;
shot[? "bulletZ"] = zht;
//shot[? "sndAttackWarn"] = "cGremlinSmall_attack"; //attacking scream (desperate)
shot[? "sndAttackStrike"] = "cGremlinSmall_gunattack";
AI_util_action_setDamage(shot, 0.1, 0, 0, 0.1, 10, 50, STAGGER_HARDNESS_SOFT);

// New attack
//attack = scr_AI_switch_standard("new_attack", conf);
//attack[? "action"] = shot; 

// Triple shot
/*attack = scr_AI_switch_standard("new_attack", conf);
var action = scr_AI_addAction(scr_AI_active_aimandshoot);
attack[? "action"] = action; 
action[? "action"] = shot;

attack[? "distMin"] = 30;
attack[? "distMax"] = 150;
attack[? "cooldownTime"] = 20; 
attack[? "cooldownTimeRnd"] = 15;
attack[? "prepTime"] = 3;   */
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Delete light
if (light != -999) Light("delete", light);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Bobbing
event_inherited();

if (paused()) exit;

z = zht - (sin(bob) * 3);
bob += dt() * 0.33; //.6 * dt();
Light("y", light, -(z * 1.5));

smkCou += dt_sec() * smkSec;
while (smkCou &gt; 1)
{
    smkCou -= 1;
    Smoke("customcolor", smkCol[0], smkCol[1], smkCol[2]);
    smk = Smoke("puff keep", x - 3 + random(6), y - 3 + random(6), z + 6, 40 + random(4));
    smk.move_x = move_x;
    smk.move_y = move_y - 12;
    smk.smoke_speed = 2;
    with (smk) { event_user(0); instance_destroy(); }
    Smoke("color", c_white);
}

if (AI_stateTopType == AI_STATETYPE_PASSIVE) exit;
if (point_distance(x, y, o_hoopz.x, o_hoopz.y) &lt; 200)
{
    proCou += dt_sec() * proSec;
    if (proCou &gt; 1)
    {
        proCou -= 1;
        pro = instance_create(x, y, o_skullpep_wisp);
        pro.z = zht;
        scr_stats_setAttackStat(pro, STAT_ATTACK_DMG_ZAUBER, proDmg);
        ds_list_copy(pro.target_list, target_list);
        //show_debug_message("wisp skull");
    }
}

//x
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

//instance_create(x, y, o_enemy_skullpep_dead);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

if (o_hoopz.y &gt; dy) img = 0; else img = 1;
if (o_hoopz.x &gt; dx) xcl = 1; else xcl = -1;
draw_sprite_ext(s_skullpep, img, dx, dy, xcl, 1, 0, c_white, 1);

combatActor_draw_post();
//draw_self();

/*var _col,pt2x,pt2y,pt3x,pt3y,_img,_hScale,_frm,_hoff,_hFrm,_showLArm,_showRArm;
_col = image_blend;

_frm = 0;
_img = 0;
_hScale = 1;
_hoff = 0;
_hFrm = 0;

_aFrmR = 0;
_aFrmL = 0;

_showLArm = true;
_showRArm = true;

_img = s_cgremlin_small_gibs;

if(a_attackName == "stagger")
{
    _body_offset = pType*12;
    
    _rightarm_offset = armTypeR*12+1;
    _leftarm_offset = armTypeL*12+1;
    
    _head_offset = headType*10;
    
    scr_entity_animation_setSpeed("body", 0);
    scr_entity_animation_setRange("body", _body_offset+1, 1);
    scr_entity_animation_setSpeed("head", 0);
    scr_entity_animation_setRange("head", _head_offset+3, 1);
    scr_entity_animation_setSpeed("left_arm", 0);
    scr_entity_animation_setRange("left_arm", _leftarm_offset+1, 1);
    scr_entity_animation_setSpeed("right_arm", 0);
    scr_entity_animation_setRange("right_arm", _rightarm_offset+1, 1);
}
else
{
    if(a_walking)
    {
        scr_entity_animation_setSpeed("body", 1);
        scr_entity_animation_setRange("body", _body_offset+2, 4);
        scr_entity_animation_setSpeed("head", 1);
        scr_entity_animation_setRange("head", _head_offset, 4);
        scr_entity_animation_setSpeed("left_arm", 1);
        scr_entity_animation_setRange("left_arm", _leftarm_offset+2, 4);
        scr_entity_animation_setSpeed("right_arm", 1);
        scr_entity_animation_setRange("right_arm", _rightarm_offset+2, 4);
        _hoff = floor(scr_entity_animation_getImage("head") mod 2);
    }
    else
    {
        scr_entity_animation_setSpeed("body", 0);
        scr_entity_animation_setRange("body", _body_offset, 1);
        scr_entity_animation_setSpeed("head", 0);
        scr_entity_animation_setRange("head", _head_offset, 1);
        
        scr_entity_animation_setSpeed("left_arm", 1);
        scr_entity_animation_setRange("left_arm", _leftarm_offset, 1);
        scr_entity_animation_setSpeed("right_arm", 1);
        scr_entity_animation_setRange("right_arm", _rightarm_offset, 1);
    }
}

_dirdir = ((faceDir+360)mod 360) div 90;
_odir = ((faceDir+360)mod 360);

switch(_dirdir)
{
    case 0: 
        _hScale = -1; 
        _body_offset= pType*12+6; 
        _rightarm_offset = armTypeR*12+6; 
        _leftarm_offset = armTypeL*12+6; 
        _head_offset = headType*10+5; 
        break;
    case 1: 
        _hScale = 1; 
        _body_offset=pType*12+6; 
        _rightarm_offset = armTypeR*12+6;  
        _leftarm_offset = armTypeL*12+6; 
        _head_offset = headType*10+5; 
        break;
    case 2: 
        _hScale = -1; 
        _body_offset=pType*12; 
        _rightarm_offset = armTypeR*12; 
        _leftarm_offset = armTypeL*12; 
        _head_offset = headType*10; 
        break;
    case 3: 
        _hScale = 1; 
        _body_offset=pType*12; 
        _rightarm_offset = armTypeR*12;  
        _leftarm_offset = armTypeL*12; 
        _head_offset = headType*10; 
        break;
}


if(a_attackName == "shot")
{
    _showRArm = false;
    if(_odir&lt;180)
    {
        _gunImg = 0;
        _xoff = 0;
        if(_odir&gt;90)
        {
            _gunImg = _odir div 30 - 3;
            _xoff = 0 - _gunImg*2;
        }
        else
        {
            _gunImg = 2 - (_odir div 30);
            _xoff = _gunImg*2;
        }
        
        draw_sprite_ext(s_cgremMed_gun,_gunImg,x+_xoff,y-8+_hoff,_hScale,1,0,_col,1);
    }   
}
else{animStrike = 0;}


draw_set_alpha(1);

global.drawBack = false;
global.drawFront = false;
///back arm
if((_odir&gt;=180 &amp;&amp; _showRArm) || (_odir&lt;180 &amp;&amp; _showLArm))
{
    draw_sprite_ext(s_cgremMed_lArm,scr_entity_animation_getImage("left_arm"),x,y-2,_hScale,1,0,_col,1);
}

draw_sprite_ext(s_cgremMed_leg,scr_entity_animation_getImage("left_arm"),x,y,_hScale,1,0,_col,1);
draw_sprite_ext(s_cgremMed_head,scr_entity_animation_getImage("head"),x,y-10+_hoff,_hScale,1,0,_col,1);

if((_odir&gt;=180 &amp;&amp; _showLArm) || (_odir&lt;180 &amp;&amp; _showRArm))
{
    _fr = _aFrmR;
    draw_sprite_ext(s_cgremMed_rArm,scr_entity_animation_getImage("right_arm"),x,y-2,_hScale,1,0,_col,1);
    
}


if(a_attackName == "shot")
{
    
    if(_odir&gt;=180)
    {
        _gunImg = 0;
        _xoff = 0;
        if(_odir&gt;270)
        {
            _gunImg = _odir div 30 - 6;
            _xoff = (_gunImg-2)*2;
        }
        else
        {
            _gunImg = 11 - (_odir div 30);
            _xoff = 0- (_gunImg-2)*2;
        }
        
        draw_sprite_ext(s_cgremMed_gun,_gunImg,x+_xoff,y-8+_hoff,_hScale,1,0,c_white,1);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>19,18</point>
    <point>20,20</point>
  </PhysicsShapePoints>
</object>
