<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_ooze01</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>EnemyCombatActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////you get all the default variables from EnemyCombatActor
event_inherited();

// Enemy stats
scr_enemyDB_statsGet(enemyBuild);

pflife = 2000;

// Enemy configurations
scr_entity_setZHitbox(0, 16);
anim = 0;
animSpd = 0.2;
animStrike = 0;

scr_stats_hook_onHit_userEvent(8);

walkSpd = 1;

deathSound = "cGremlinSmall_death";
damageSound = "cGremlinSmall_grunt";

// Movement
var movement = scr_AI_movement_init(scr_AI_movementType_standard);
movement[? "turnSpd"] = 6;

// Passive and active states
var ark, conf, attack, attacks,guard;
scr_AI_addPassiveState(scr_AI_passive_none);
conf = scr_AI_addActiveState(scr_AI_active_approach);
conf[? "stopAtDistance"] = 32;
conf[? "walkScript"] = movement;

// Create and configure AI switch
/////////////////////setup AI Switch and attacks
_aiswitch = scr_AI_setSwitch(scr_AI_switch_conditions);
ds_map_replace(_aiswitch,"attackInterval",10); ///added interval between every attack
attacks = ds_map_find_value(_aiswitch, "attacks");

swFromX1 = x;
swFromY1 = y;
swToX1 = x;
swToY1 = y;

swFromX2 = x;
swFromY2 = y;
swToX2 = x;
swToY2 = y;

swFromX3 = x;
swFromY3 = y;
swToX3 = x;
swToY3 = y;

swFromX4 = x;
swFromY4 = y;
swToX4 = x;
swToY4 = y;

blockAngle = 0;
blockUp = 0;
///special AI state is swordUp
swordUp = 0;
count = 0;

startAngle=0;
endAngle=0;
swordRange = 0;
swordCheck = false;
lightningCharge = 0;
spawnAtkObj = false;

command = ""; // temp fix

///////////////////////////////////////ON SWORD UP:
////GREAT DROP (Jumps up in the air, falls back on target, limited range from jump point. Dodge at last second or move far away to avoid) If lightning-charged, is followed by random lightning strikes around the room.
////End the attack by facing towards the angle of the jump, ignoring targets' position. (opportunity to attack ooze's back)
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Great Drop");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 6);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is at low to mid range
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "swordUp");

////LIGHTNING CHARGE (Lightning strikes the sword, which damages you if you are close, and temporarily makes Ooze faster, his sword wider and longer, deals extra zauber damage and sword strikes shoot projectiles.
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Lightning Charge");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 4);

///////Can do this three times in the battle. The first time after Ooze initially lifts his sword
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is mid to long range. First charge
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "distMin", 96);
ds_map_add(attack, "ammo", 1); ////only does this once
ds_map_add(attack, "needState", "swordUp");

///////Second time is unlocked at 50% HP
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is mid to long range. Second charge
ds_map_add(attack, "lifePercBelow",50);
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "distMin", 96);
ds_map_add(attack, "ammo", 1);
ds_map_add(attack, "needState", "swordUp");

///////Third time is unlocked at 30% HP
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is mid to long range. Third charge
ds_map_add(attack, "lifePercBelow",30);
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "distMin", 96);
ds_map_add(attack, "ammo", 1);
ds_map_add(attack, "needState", "swordUp");

///////at 10% HP, can do it infinitely, no ammo restriction.
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is mid to long range. Third charge
ds_map_add(attack, "lifePercBelow",10);
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "distMin", 96);
ds_map_add(attack, "needState", "swordUp");


////LUNGE THRUST (sudden trust forward at the target, all ranges, works in all directions). Face towards the target by 40 degrees at the end of the attack. Attack is sudden, and gives little time for a riposte
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Lunge Thrust");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 3);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is very close, regardless of direction
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "swordUp");


//////////////////////////////////////////////ON SWORD DOWN:
////RAISE SWORD. Very Low priority action, not done if target is too close. Temporarily changes oozes' moveset. Unlocked when life is below 70%
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "attackName", "Raise Sword");
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "beforeTime", 2);
ds_map_replace(conf, "afterTime", 2);
atkRaiseSword = ds_map_create(); ///give it another name to refer to it later
ds_map_add(atkRaiseSword, "action", scr_AI_action_userEvent);
ds_map_add(atkRaiseSword, "attackPriority", 3);///low priority
ds_map_add(atkRaiseSword, "actionMap", conf);
ds_list_add(attacks, atkRaiseSword);
///Attack performed if target is close, regardless of direction
ds_map_add(atkRaiseSword, "noRepeat", true);
ds_map_add(atkRaiseSword, "lifePercBelow",90);
ds_map_add(atkRaiseSword, "distMin", 64);
ds_map_add(atkRaiseSword, "avoidState","swordUp");

////SWORD SPIN. Attack that hits all around Ooze at a low-mid range, but has a solid tell for hoopz to walk or dodge away. End the attack always facing hoopz directly, and link up the next move almost immediately. 
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Sword Spin");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 2);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 6);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is close, regardless of direction
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "avoidState","swordUp");
ds_map_add(attack, "distMax", 64);

////SLASH COMBO. STEP FORWARD AND THEN 3-SLASH COMBO. INTERRUPT COMBO IF TARGET MOVES TOO FAR.
///BETWEEN EACH STRIKE, WALK AND TURN A BIT TO CORRECT AIMING, BUT ONLY UP TO A POINT.
///Ends the combo by turning 40 degrees towards player, possibly facing Hoopz
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "3SlashCombo");
ds_map_replace(conf, "beforeTime", 2);
ds_map_replace(conf, "afterTime", 3);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 12);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is directly in front, left-forward or right-forward, at low to mid range
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "forward");
ds_map_add(attack, "needStateAlt1", "leftFwd");
ds_map_add(attack, "needStateAlt2", "rightFwd");
ds_map_add(attack, "distMax", 96);


////FORWARD THRUST. Quick short-middle range thrusting attack that has little time to react to, but some extra time for a riposte after the strike.
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Forward Thrust");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 6);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is directly in front, at medium range
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "forward");
ds_map_add(attack, "distMin", 16);
ds_map_add(attack, "distMax", 128);


////FORWARD RUSH. Running attack ending with a horizontal slice. Somewhat seeks target, but dodging left or right should avoid it. Ooze ends looking towards the slice. (opportunity to attack ooze's back)
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Forward Rush");
ds_map_replace(conf, "beforeTime", 4);
ds_map_replace(conf, "afterTime", 6);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is directly in front, at long range
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "forward");
ds_map_add(attack, "distMin", 64);


///LEFT CRESCENT SLASH. Wide slash attack, medium range, triggers from left side to forward. Turns Ooze 20 degrees to the left.
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Left Crescent");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 2);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "forward");
ds_map_add(attack, "needStateAlt1", "leftMid");
ds_map_add(attack, "needStateAlt2", "leftFwd");
ds_map_add(attack, "distMin", 16);
ds_map_add(attack, "distMax", 128);


///RIGHT CRESCENT SLASH. Wide slash attack, medium range, triggers from right side to forward. Turns Ooze 20 degrees to the right.
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Right Crescent");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 2);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "forward");
ds_map_add(attack, "needStateAlt1", "rightMid");
ds_map_add(attack, "needStateAlt2", "rightFwd");
ds_map_add(attack, "distMin", 16);
ds_map_add(attack, "distMax", 128);


////BACK SLICE. Sudden turn with a slightly narrow but longer range version of Crescent slash, aimed straight backwards. Turns Ooze 180 degrees. Has a bit of extra time before the attack, but not much after
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Back Slice");
ds_map_replace(conf, "beforeTime", 5);
ds_map_replace(conf, "afterTime", 3);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is behind, at medium range
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "backward");
ds_map_add(attack, "needStateAlt1", "leftBck");
ds_map_add(attack, "needStateAlt2", "rightBck");
ds_map_add(attack, "distMin", 48);
ds_map_add(attack, "distMax", 128);


////SOMERSAULT. Sudden hop backwards to get behind a player that is right behind ooze.
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Somersault");
ds_map_replace(conf, "beforeTime", 3);
ds_map_replace(conf, "afterTime", 2);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10);///medium priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is behind, at medium range
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "backward");
ds_map_add(attack, "distMax", 96);


////QUICK TURN. Ooze quickly turns towards the player, hopping to a spot to ready the next attack.
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Quick Turn");
ds_map_replace(conf, "beforeTime", 1);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);///low priority
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
///Attack performed if target is behind, at medium range
ds_map_add(attack, "noRepeat", true);
ds_map_add(attack, "needState", "leftBck");
ds_map_add(attack, "needStateAlt1", "rightBck");
ds_map_add(attack, "needStateAlt2", "leftMid");
ds_map_add(attack, "needStateAlt3", "rightMid");
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

count +=1;

var _dt = dt();
swordUp-= _dt;
lightningCharge -= _dt;

////disable raising the sword during lightning charge
if(lightningCharge&gt;280)
{
    ds_map_add(atkRaiseSword, "disabled", true);
}
else if(lightningCharge&lt;5 &amp;&amp; lightningCharge&gt;-30)
{
    ds_map_add(atkRaiseSword, "disabled", false);
}

///if(atkRaiseSword atkCharge 

if(count &gt;4)
{////checks for relative direction of hero compared to beam sword
    if(swordUp&gt;0){ai_curState = "swordUp";}
    else
    {
        if(I_AI_target!=noone &amp;&amp; instance_exists(I_AI_target))
        {
            var tDir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
            var sDir = (tDir - faceDir + 360) mod 360;
            if(sDir&lt;=10){ai_curState = "forward";}
            else if(sDir&lt;=50){ai_curState = "leftFwd";}
            else if(sDir&lt;=120){ai_curState = "leftMid";}
            else if(sDir&lt;=160){ai_curState = "leftBack";}
            else if(sDir&lt;=200){ai_curState = "backward";}
            else if(sDir&lt;=240){ai_curState = "rightBack";}
            else if(sDir&lt;=310){ai_curState = "rightMid";}
            else if(sDir&lt;=350){ai_curState = "rightFwd";}
            else{ai_curState = "forward";}
        }
    }
    count = 0;
    //show_debug_message(ai_curState);
    pflife = scr_stats_getCurrentStat(id,STAT_CURRENT_HP)/scr_stats_getEffectiveStat(id,STAT_EFFECTIVE_MAX_HP);
    ds_map_replace(_aiswitch,"attackInterval",2+10*pflife); ///added interval between every attack
}

if(blockAngle!=0)
{
    if(blockUp&gt;0)
    {
        blockUp-=1;
        if(blockAngle&gt;0){blockAngle+=5;}
        else{blockAngle-=5;}
    }
    else
    {
        if(blockAngle &gt; _dt){blockAngle-=_dt}else{blockAngle = 0;}
        if(blockAngle &lt; 0-_dt){blockAngle += _dt}else{blockAngle = 0;}
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(isBlocking)
{
    var atk = argument_attackId;
    var atkDir = point_direction(x, y, atk.xprevious, atk.yprevious);
    var rdif = abs(scr_math_rdif(atkDir,faceDir));
    if (rdif &lt;= 50)
    {
        blockAngle = (random(5)+5)*choose(1,-1);
        blockUp = 3+irandom(3);
        callback_allowDamage = false;
        // Create bounce-back bullet
        var n = instance_create(atk.x, atk.y - atk.z, o_fakeBullet);
        n.direction = atk.move_dir + 120+random(120);
        n.sprite_index = atk.sprite_index;
        n.image_xscale = atk.image_xscale;
        n.image_yscale = atk.image_yscale;
        n.image_index = atk.image_index;
        n.image_angle = n.direction;
        n.spd = atk.move_dist;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ATTACK ACTIONS

///local vars that allow the attack actions to configure the slash collision check at the end of this script:
var slashAngleKnock = 0;
var dmgRatio = 1;
swordCheck = false;
startAngle=0;
endAngle=0;
swordRange = 0;


var movSpd = 0;
var turnSpd = 0;

////THIS HANDLES ALL OF OOZES' ATTACK ACTIONS:
switch(a_attackState)
{
    case "reset": ///reset attack actions' timing vars
        I_atk_evnt_intBefore = ds_map_find_value(conf, "beforeTime");
        I_atk_evnt_intDamage = ds_map_find_value(conf, "damageTime");
        I_atk_evnt_intAfter = ds_map_find_value(conf, "afterTime");
        I_atk_evnt_didAttack = false;
        a_attackAnim = 0;
        a_attackState = "before";
        a_attackSubState = 0;
        a_zmvSpd = 0;
        didAtk = false;
        scr_entity_setMoveXY(0, 0);
        break;
        
    case "before": ///timing before any attack anim
        switch(a_attackName) 
        {
            case "3SlashCombo":
                turnSpd = 4;
                movSpd = 8;
                break;
                
            case "Forward Rush":
                turnSpd = 10;
                movSpd = 2;
                break;
                
            case "Forward Thrust":
                turnSpd = 6;
                movSpd = 4;
                break;
                
            case "Lunge Thrust":
                movSpd = 1;
                turnSpd = 20;
                break;
        }
        
        if(a_attackAnim&lt;I_atk_evnt_intBefore)
        {
            a_attackAnim+= dt();
        }
        else
        {
            a_attackAnim = 0;
            a_attackState = "damage";
            spawnAtkObj = true;
        }
        break;
        
    case "damage": ///action itself
        switch(a_attackName)
        {
            case "Great Drop":
                //a_attackState = "after"; a_attackAnim = 0;
                //swordUp = 0;
                if(a_attackAnim==0)
                {
                    a_zmvSpd=50;
                    show_debug_message("GreatDropStart");
                }
                
                a_attackAnim += dt();
                if(a_zmvSpd&gt;0)
                {
                    a_zmvSpd-=dt()*5;
                    turnSpd = 180;
                    movSpd = 16;
                }
                else
                {
                    if(z&gt;0){if(a_zmvSpd&gt;-70){a_zmvSpd-=dt()*10;}}
                    else
                    {
                        swordCheck = true; swordRange = 64;
                        startAngle=0; endAngle=360;
                        z = base_z; a_zmvSpd = 0; a_attackState = "after"; a_attackAnim = 0;
                    }
                }
                move_z = a_zmvSpd;
                show_debug_message("move z- "+string(move_z)  + " z- " +string(z));
                break;
                
            case "Lightning Charge":
                lightningCharge = 300;
                a_attackState = "after"; a_attackAnim = 0;
                swordUp = 0;
                break;
                
            case "Lunge Thrust":
                slashAngleKnock = 0;
                dmgRatio = 2; ///the thrust is a strong attack
                startAngle=-8; endAngle=8;
                swordUp = 0;
                
                if(a_attackAnim&lt;4)
                {
                    swordRange = 52;
                    turnSpd = 10;
                    swordCheck = true;
                    movSpd = 2;
                }
                else if(a_attackAnim&lt;14)
                {
                    swordRange = 96;
                    turnSpd = 2;
                    swordCheck = true;
                    movSpd = 24;
                }
                else if(a_attackAnim&lt;18)
                {
                    swordRange = 72;
                    turnSpd = 2;
                    swordCheck = true;
                    movSpd = 12;
                }
                else if(a_attackAnim&lt;22)
                {
                    swordRange = 64;
                    swordCheck = true;
                    turnSpd = 2;
                    movSpd = 6;
                }
                else
                {
                    a_attackState = "after"; a_attackAnim = 0;
                }
                a_attackAnim += dt();
                break;
                     
            case "Raise Sword":
                swordUp = 60;
                a_attackState = "after"; a_attackAnim = 0;
                break;
                
            case "Sword Spin":
                slashAngleKnock = 30;
                dmgRatio = 1;
                swordCheck = true;
                swordRange = 96;
                switch(floor(a_attackAnim*2))
                {
                    case 0: startAngle=-100; endAngle=-80; break;
                    case 1: startAngle=-90; endAngle=-45; break;
                    case 2: startAngle=-50; endAngle=0; break;
                    case 3: startAngle=-20; endAngle=45; break;
                    case 4: startAngle= 20; endAngle=135; break;
                    case 5: startAngle= 100; endAngle=225; break;
                    case 6: startAngle= 210; endAngle=315; break;
                    case 7: startAngle= 320; endAngle=405; break;
                    case 8: startAngle= 380; endAngle=435; break;
                    case 9: startAngle= 410; endAngle=440; break;
                    case 10: startAngle=435; endAngle=443; break;
                    default: swordCheck = false; break;
                    break;
                }
                a_attackAnim+=dt();
                if(a_attackAnim*2&gt;=11)
                {
                    a_attackState = "after"; a_attackAnim = 0;
                    faceDir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
                }
                break;
         
            case "3SlashCombo":
                dmgRatio = 1;
                swordCheck = true;
                swordRange = 80; ///slightly lower range for the back slice
                
                if(a_attackSubState==1)
                {
                    slashAngleKnock = -30;
                    switch(floor(a_attackAnim*2))
                    {
                        case 0: startAngle= 40; endAngle= 45; break;
                        case 1: startAngle= -10; endAngle=20; break;
                        case 2: startAngle=-30; endAngle=-20; break;
                        case 3: startAngle=-40; endAngle=-20; break;
                        case 4: startAngle=-45; endAngle=-40; break;
                        default: swordCheck = false; break;
                    }
                }
                else
                {
                    slashAngleKnock = 30;
                    switch(floor(a_attackAnim*2))
                    {
                        case 0: startAngle=-45; endAngle=-40; break;
                        case 1: startAngle=-20; endAngle=10; break;
                        case 2: startAngle=20; endAngle=30; break;
                        case 3: startAngle=30; endAngle=40; break;
                        case 4: startAngle=40; endAngle=45; break;
                        default: swordCheck = false; break;
                    }
                }
                
                a_attackAnim+=dt();
                if(a_attackAnim*2&gt;=5)
                {
                    show_debug_message("Substate "+string(a_attackSubState));
                    if(a_attackSubState&lt;2){a_attackState = "before"; a_attackAnim = 2;}
                    else{a_attackState = "after"; a_attackAnim = 0;}
                    a_attackSubState+=1;
                }
                break;
                
            case "Forward Thrust":
                slashAngleKnock = 0;
                dmgRatio = 2; ///the thrust is a strong attack
                swordCheck = true;
                startAngle=-8; endAngle=8;
                turnSpd = 2;
                movSpd = 8;
                switch(floor(a_attackAnim*2))
                {
                    case 0: swordRange = 48; break;
                    case 1: swordRange = 96; break;
                    case 2: swordRange = 128; break;
                    case 3: swordRange = 56; break;
                    default: swordCheck = false; break;
                }
                a_attackAnim+=dt();
                if(a_attackAnim*2&gt;=4){a_attackState = "after"; a_attackAnim = 0;}
                break;
                
            case "Forward Rush":
                slashAngleKnock = 30;
                dmgRatio = 1;
                swordRange = 72; ///slightly lower range for the back slice
                
                if(a_attackAnim&gt;8)
                {
                    swordCheck = true;
                    switch(floor((a_attackAnim-8)*2))
                    {
                        case 0: startAngle=-45; endAngle=-40; break;
                        case 1: startAngle=-20; endAngle=10; break;
                        case 2: startAngle=20; endAngle=30; break;
                        case 3: startAngle=30; endAngle=40; break;
                        case 4: startAngle=40; endAngle=45; break;
                        case 5: a_attackState = "after"; a_attackAnim = 0;break;
                        default: swordCheck = false; break;
                    }
                }
                else
                {
                    turnSpd = 2;
                    movSpd = 24;
                }
                a_attackAnim+=dt();
                break;
                
            case "Left Crescent":
                slashAngleKnock = 30;
                dmgRatio = 1;
                swordCheck = true;
                swordRange = 96;
                switch(floor(a_attackAnim*2))
                {
                    case 0: startAngle= 140; endAngle=160; break;
                    case 1: startAngle= 45; endAngle=150; break;
                    case 2: startAngle=-20; endAngle=90; break;
                    case 3: startAngle=-40; endAngle=45; break;
                    case 4: startAngle=-45; endAngle=-10; break;
                    case 5: startAngle=-50; endAngle=-30; break;
                    default: swordCheck = false; break;
                }
                a_attackAnim+=dt();
                if(a_attackAnim*2&gt;=6){a_attackState = "after"; a_attackAnim = 0; faceDir = (faceDir + 60)mod 360;}
                break;
                
            case "Right Crescent":
                slashAngleKnock = -30;
                dmgRatio = 1;
                swordCheck = true;
                swordRange = 96;
                switch(floor(a_attackAnim*2))
                {
                    case 0: startAngle=-160; endAngle=-140; break;
                    case 1: startAngle=-150; endAngle=-45; break;
                    case 2: startAngle=-90; endAngle=20; break;
                    case 3: startAngle=-45; endAngle=40; break;
                    case 4: startAngle=10; endAngle=45; break;
                    case 5: startAngle=30; endAngle=50; break;
                    default: swordCheck = false; break;
                }
                a_attackAnim+=dt();
                if(a_attackAnim*2&gt;=6){a_attackState = "after"; a_attackAnim = 0; faceDir = (faceDir + 360-60)mod 360;}
                break;
                
            case "Back Slice":
                slashAngleKnock = 30;
                dmgRatio = 1;
                swordCheck = true;
                swordRange = 80; ///slightly lower range for the back slice
                switch(floor(a_attackAnim*2))
                {
                    case 0: startAngle=-130; endAngle=-120; break;
                    case 1: startAngle=-200; endAngle=-130; break;
                    case 2: startAngle=-230; endAngle=-160; break;
                    case 3: startAngle=-240; endAngle=-200; break;
                    case 4: startAngle=-245; endAngle=-220; break;
                    default: swordCheck = false; break;
                }
                a_attackAnim+=dt();
                if(a_attackAnim&gt;=5*2){a_attackState = "after"; a_attackAnim = 0; faceDir = (faceDir + 180)mod 360;}
                break;
                
            case "Somersault":
                a_attackState = "after"; a_attackAnim = 0;
                var pdir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
                var pdist = point_distance(x,y,I_AI_target.x,I_AI_target.y);
                x+=lengthdir_x(pdist+32,pdir);
                y+=lengthdir_y(pdist+32,pdir);
                faceDir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
                break;
                
            case "Quick Turn":
                a_attackState = "after"; a_attackAnim = 0;
                faceDir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
                break;
  
            default:
                if(a_attackAnim &lt; I_atk_evnt_intDamage)
                {
                    if(a_attackAnim==0){}
                    a_attackAnim+= dt();
                    if (!I_atk_slsh_didAttack)
                    {
                        I_atk_slsh_didAttack = true;
                    }
                }
                else
                {
                    a_attackAnim = 0;
                    I_atk_slsh_state = "after";
                }
                
                break;
        }
        break;
        
    case "after": ///timing after attack anim
        if (a_attackAnim &lt; I_atk_evnt_intAfter)
        {
            a_attackAnim += dt();
        }
        else
        {
            a_attackState = "reset";
            stateResult = AI_STATERESULT_REMOVE;
        }
        break;
}

show_debug_message(a_attackState);

/////HANDLES MOVEMENT DURING ATTACK PATTERNS
if(turnSpd&gt;0)
{
    scr_AI_util_turnTowards(I_AI_target.x,I_AI_target.y, turnSpd);
    direction = faceDir;
}

if(movSpd&gt;0)
{
    show_debug_message(string(movSpd));
    move_x =  cos(degtorad(direction)) * movSpd;
    move_y = -sin(degtorad(direction)) * movSpd;
}
else
{
    move_x = 0;
    move_y = 0;
}

/////THIS HANDLES ALL OF OOZE's SWORD COLLISIONS
////need to do proper collisions here:
if(swordCheck)
{
    /*
    var tDir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
    var tDist = point_distance(x,y,I_AI_target.x,I_AI_target.y);
    var startDir = (startAngle + faceDir) mod 360;
    var endDir = (endAngle + faceDir) mod 360;
    var targetHit = false;
    
    if(lightningCharge&gt;0){swordRange += 32 + 64*lightningCharge/200;}
    
    if(tDist &lt;= swordRange) ///target within range of sword slash
    {
        if(startDir&gt;endDir) ///within angle of strike
        {///the check goes over 0
            if(tDir&gt;startDir || tDir&lt;endDir)
            {
                targetHit = true;
            }
        }
        else
        {
            if(tDir&gt;startDir &amp;&amp; tDir&lt;endDir)
            {
                targetHit = true;
            }
        }
    }
    */
    
    if(spawnAtkObj &amp;&amp; !didAtk)
    {
        didAtk = true;
        var obj = instance_create(x,y,o_enemyAttack_melee_static);
        obj.sprite_index = s_oozeSlash;
        obj.image_xscale = 1;
        obj.image_yscale = 1;
        show_debug_message("sword range before charge: "+string(swordRange));
        if(lightningCharge&gt;0)
        {
            obj.image_xscale = 1.6 + lightningCharge/300;
            obj.image_yscale = 1.6 + lightningCharge/300;
            swordRange = swordRange*1.6 + swordRange*lightningCharge/300;
        }
        show_debug_message("sword range after charge: "+string(swordRange));
        obj.lifetime = 4;
        obj.parent = id;
        obj.mask_index = s_oozeSlash
        ds_list_copy(obj.target_list, target_list);
        
        scr_stats_setAttackStat(obj,STAT_ATTACK_DMG_NORMAL,20*dmgRatio); ///base damage of sword attacks
        if(lightningCharge&gt;0){scr_stats_setAttackStat(obj,STAT_ATTACK_DMG_CYBER, 10 + lightningCharge/300*20);} ///added cyber damage if sword is charged
        spawnAtkObj = false
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

draw_sprite_ext(sprite_index,0,dx,dy,1,1,0,c_white,1);

scr_artDebugPlaceholder();

var fx = x+ lengthdir_x(16,faceDir+blockAngle);
var fy = y+ lengthdir_y(16,faceDir+blockAngle);

var tx = x+ lengthdir_x(48,faceDir+blockAngle);
var ty = y+ lengthdir_y(48,faceDir+blockAngle);

if(!swordCheck)
{
    draw_set_color(c_green);
    draw_set_alpha(0.1);
    draw_line_width(swFromX4,swFromY4,swToX4,swToY4,2);
    draw_set_alpha(0.2);
    draw_line_width(swFromX3,swFromY3,swToX3,swToY3,2);
    draw_set_alpha(0.4);
    draw_line_width(swFromX2,swFromY2,swToX2,swToY2,2);
    draw_set_alpha(0.6);
    draw_line_width(swFromX1,swFromY1,swToX1,swToY1,2);
    draw_set_alpha(0.1);
    draw_line_width(fx,fy,tx,ty,2);
}

swFromX4 = swFromX3;
swFromY4 = swFromY3;
swToX4 = swToX3;
swToY4 = swToY3;

swFromX3 = swFromX2;
swFromY3 = swFromY2;
swToX3 = swToX2;
swToY3 = swToY2;

swFromX2 = swFromX1;
swFromY2 = swFromY1;
swToX2 = swToX1;
swToY2 = swToY1;

swFromX1 = fx;
swFromY1 = fy;
swToX1 = tx;
swToY1 = ty;

if(swordCheck)
{
    show_debug_message("sword range "+string(swordRange));
    var startDir = (startAngle + faceDir);
    var endDir = (endAngle + faceDir);
    if(lightningCharge&gt;0){draw_set_color(c_aqua);}else{draw_set_color(c_blue);}
    if(startDir&gt;endDir){scr_draw_circle_angle(x,y,endDir,startDir,10,16,swordRange);}
    else{scr_draw_circle_angle(x,y,startDir,endDir,10,16,swordRange);}
    
    swordCheck = false;
}

draw_set_alpha(1);
draw_text(x,y+32,"life "+string(pflife*100) + "%");

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>22,49</point>
    <point>28,28</point>
  </PhysicsShapePoints>
</object>
