<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2510002</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// scr_event_choice_init()
/// Initializes a choice object.
/// Automatically runs when a choice object is created.
/// Note: Most of these variables are initialized in scr_event_action_choice.

// The title of the text, defaults to an empty string.
_title = NULL_STRING;
// The portrait for this text, defaults to NULL.
_portrait = NULL;
// The choices to be displayed. The amount of choices in the 
// box at once is dependent on how many lines.
_choices = NULL;
_choice_events = NULL;
_choice_number = 0;
_choice_lines = NULL;
// The x offset to draw the dialogue at, defaults to 8.
_draw_x = 8;
// The y offset to draw the dialogue at, defaults to 0.
_draw_y = 140;
// The width of the textbox, defaults to SCREEN_WIDTH - 16.
_width = SCREEN_WIDTH - 16;
// The width of the text, defaults to 64 less than width.
_text_width = _width - 64;
// The amount of lines this textbox has, defaults to 4.
_lines = 4;
// The amount of characters that are added per 1/10s, defaults to 3.
_text_speed = 3;

// The different colors for the different texts, defaults are set below.
_title_color = c_ltblue;
_text_color = c_white;
_selection_color = make_color_rgb(255, 200, 50);
_highlight_color = c_white;
_lowlight_color = make_color_rgb(176, 181, 165);

// The sound used whenever a new choice is selected.
_choice_sound = "sn_talk1";
// The sound used whenever a textbox is completed and the player selects to go to the next one.
_confirm_sound = "sn_talk3";

// The event associated with this dialogue, defaults to null, but should always be set to something...
_event = NULL;

// The top choice currently being displayed.
_start_choice = 0;
// The currently selected choice.
_current_choice = 0;
// The start choices each page.
_page_starts = ds_list_create();
_current_page = 0;
// The text that should be displayed currently.
_draw_text = "";
// The selected choice, which should be highlighted.
_selection_text = "";
// Which line to start the selection at (with some choices spanning multiple lines, it gets tricky!).
_selection_line = 0;
// If the button to confirm has been released since the last confirmation.
_confirm_released = false;
// Bob amount for the selection cursor.
_bob = 0;
// Variables for if the arrows should even be displayed.
_display_up_arrow = false;
_display_down_arrow = false;
// The colors for the arrows.
_up_arrow_color = _lowlight_color;
_down_arrow_color = _lowlight_color;

// View variables used for drawing.
_frame_left = NULL;
_frame_top = NULL;
_frame_right =NULL;
_frame_bottom = NULL;

_text_top = NULL;
_text_left = NULL;

_more_choices_left = NULL;
_more_choices_up_top = NULL;
_more_choices_down_top = NULL;

// Check for analog stick held GZ Added
held = -1;
heldCou = 0;
style = 1;

// To be compatible
_boxless = false;
_normal_backdrop = true;
_mystery_backdrop = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// scr_event_choice_destroy()
/// Automatically runs from the choice destroy event.

var event = ds_list_find_value(_choice_events, _current_choice);
global.cinCho = _current_choice;
ds_list_destroy(_choices);
ds_list_destroy(_choice_events);
ds_list_destroy(_choice_lines);
ds_list_destroy(_page_starts);

event._event_cursor = 0;
scr_event_advance(event);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// scr_event_choice_step()
/// Script for stepping when the choice is active.
/// Automatically runs from the choice step event.
vxv = 0; //_frame_left from _text_left has it
vyv = 0; //
if (_event._skipping) {
    instance_destroy();
    exit;
}

// If the game is not paused, look for button presses.
var pause = paused();
// Is true if any of the buttons are currently being pressed, false otherwise.
var up_pressed = false;
var down_pressed = false;
// True if a confirm button was just pressed in this frame, false otherwise.
var confirm = false;
// Only check for presses when the dialogue isn't paused.
if (!pause) {
    up_pressed = scr_input_check_pressed(KEYID_UP, PLAYER1);
    down_pressed = scr_input_check_pressed(KEYID_DOWN, PLAYER1);
    
    // Fix for ticket #1116
    if (global.keyinput_type == KEYINPUT_GAMEPAD)
    {
        up_pressed = scr_input_check_pressed(KEYID_GUNBAG, PLAYER1);
        down_pressed = scr_input_check_pressed(KEYID_ITEM_NEXT, PLAYER1);
        
        //Analog stick
        if (scr_input_check_held(KEYID_UP, PLAYER1))
        {
            if (held == 0)
            {
                heldCou += dt_sec();
                if (heldCou &gt; 0.33) { up_pressed = 1; heldCou = 0; }
            }
            held = 0;
        }
        else if (scr_input_check_held(KEYID_DOWN, PLAYER1))
        {
            if (held == 1)
            {
                heldCou += dt_sec();
                if (heldCou &gt; 0.33) { down_pressed = 1; heldCou = 0; }
            }
            held = 1;
        }
        else
        {
            heldCou = 99;
            held = -1;
        }
    }
    // Fix for ticket #1116
    
    // Laz added test, for ticket #948 // Seems to work after testing, keeping this in for now //
    if up_pressed = false then up_pressed = mouse_wheel_up();
    if down_pressed = false then down_pressed = mouse_wheel_down();
    
    // Check to see if the confirm button was just pressed or not.
    if ((scr_input_check_pressed(KEYID_DIALOGUE, PLAYER1) or (scr_input_check_pressed(KEYID_ACTION, PLAYER1) 
         and global.keyinput_type == KEYINPUT_KEYBOARD_MOUSE)) and _confirm_released) {
        confirm = true;
        _confirm_released = false;
    }
    // If the buttons are released, make sure the player can confirm again.
    if (!scr_input_check_pressed(KEYID_DIALOGUE, PLAYER1) and ((!scr_input_check_pressed(KEYID_ACTION, PLAYER1) 
        and global.keyinput_type == KEYINPUT_KEYBOARD_MOUSE) or global.keyinput_type = KEYINPUT_GAMEPAD) and !_confirm_released) {
        _confirm_released = true;
    }
    visible = 1;
} else {
    visible = 0;
}

if (!pause) {
    // Grab the current choice before doing anything.
    var old_choice = _current_choice;

    // Update the arrows for hovering and colors.
    var on_up_arrow = scr_mouse_rect(vxv + _more_choices_left, vyv + _more_choices_up_top, vxv + _more_choices_left + sprite_get_width(s_more), vyv + _more_choices_up_top + sprite_get_height(s_more));
    if (_display_up_arrow) {
        // Adjust highlights.
        if (on_up_arrow) {
            _up_arrow_color = _highlight_color;
        } else {
            _up_arrow_color = _lowlight_color;
        }
        // If an arrow is pressed, adjust the choices.
        if (on_up_arrow and _display_up_arrow and confirm) {
            _current_choice = ds_list_find_value(_page_starts, _current_page - 1);
        }
    }

    // Now do it for down!
    var on_down_arrow = scr_mouse_rect(vxv + _more_choices_left, vyv + _more_choices_down_top, vxv + _more_choices_left + sprite_get_width(s_more), vyv + _more_choices_down_top + sprite_get_height(s_more));
    if (_display_down_arrow) {
        // Adjust highlights.
        if (on_down_arrow) {
            _down_arrow_color = _highlight_color;
        } else {
            _down_arrow_color = _lowlight_color;
        }
        // If an arrow is pressed, adjust the choices.
        if (on_down_arrow and _display_down_arrow and confirm) {
            _current_choice = ds_list_find_value(_page_starts, _current_page + 1);
        }
    }

    // If up or down are pressed, change the selection.
    if (up_pressed) {
        _current_choice = max(_current_choice - 1, 0);
    }
    if (down_pressed) {
        _current_choice = min(_current_choice + 1, _choice_number - 1);
    }
    
    // Find the next page start choice.
    var next_page_start = _choice_number;
    if (_current_page &lt; ds_list_size(_page_starts) - 1) {
        next_page_start = ds_list_find_value(_page_starts, _current_page + 1);
    }
    
    // Change the page if the selection has changed sufficiently.
    if (_current_choice &gt;= next_page_start) {
        _current_page++;
        _start_choice = ds_list_find_value(_page_starts, _current_page);
    }
    if (_current_choice &lt; _start_choice) {
        _current_page--;
        _start_choice = ds_list_find_value(_page_starts, _current_page);
    }
    
    // Gonna have to do it again because the pages might have shifted...
    next_page_start = _choice_number;
    if (_current_page &lt; ds_list_size(_page_starts) - 1) {
        next_page_start = ds_list_find_value(_page_starts, _current_page + 1);
    }
    
    // If the cursor has moved, see if we should change the current choice.
    if ((o_curs.x != o_curs.xp or o_curs.y != o_curs.yp) and scr_mouse_rect(vxv + _frame_left, vyv + _frame_top, vxv + _frame_right, vyv + _frame_bottom) ) {
        var current_line = 0;
        for (var i = _start_choice; i &lt; next_page_start; i++) {
            var arrow_width = sprite_get_width(s_selection_arrow);
            var num_lines = ds_list_find_value(_choice_lines, i);
            if (scr_mouse_rect(vxv + _text_left, vyv + _text_top + current_line * 11, vxv + _text_left + 300 /*+ arrow_width + string_width(ds_list_find_value(_choices, i))*/, vyv + _text_top + (current_line + num_lines) * 11)) {
                _current_choice = i;
            }
            current_line += num_lines;
        }
    }

    // Play a sound if the choice selection changes.
    if (old_choice != _current_choice) {
        audio_play_sound_fresh(_choice_sound, 100, false);
    }

    // Variables for if the arrows should even be displayed.
    _display_up_arrow = _start_choice != 0;
    _display_down_arrow = next_page_start != _choice_number;

    // Create the draw string.
    _draw_text = "";
    var current_line = 0;
    for (var i = _start_choice; i &lt; next_page_start; i++) {
        if (i == _current_choice) {
            _selection_text = ds_list_find_value(_choices, i);
            _selection_line = current_line;
        } else {
            current_line += ds_list_find_value(_choice_lines, i);
        }
        _draw_text += ds_list_find_value(_choices, i) + DIALOGUE_CARRY;
    }
    
    // Bob the selection cursor.
    _bob = (_bob + 0.6*dt()) mod 2;
    
    // Check for confirmation.
    var confirm_destroy = confirm;
    if (scr_input_check_pressed(KEYID_ACTION, PLAYER1) and 
        global.keyinput_type == KEYINPUT_KEYBOARD_MOUSE &amp;&amp; !scr_mouse_rect(vxv + _frame_left, vyv + _frame_top, vxv + _frame_right, vyv + _frame_bottom)) {
        confirm_destroy = false;
    }
    if (confirm and confirm_destroy and !on_up_arrow and !on_down_arrow) {
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// scr_event_choice_draw()
/// Draws the choice.
/// Automatically runs from the choice draw event.

Breakout("draw", _selection_line);

// Set where to draw the choice.
x = view_xview + _draw_x;
y = view_yview + _draw_y;

// Update where to place the frame.
_frame_left = x;
_frame_top = y;
_frame_right = x + _width;
_frame_bottom = y + _lines * 12 + 44;

if (global.borderOnce == 0)
{
    global.borderOnce = 1;
    Border("generate", 10, _frame_right - _frame_left, _frame_bottom - _frame_top);
}

// Set the alpha if it is on top of the hud.
var alpha = 1 - o_hud.hudHide;

// Draw the background.
//if (style == 0)
if (global.dialogFrame != s_diag_frame || _mystery_backdrop || _boxless) then
    draw_spr_tiled(_frame_left + 4, _frame_top + 4, _frame_right - 4, _frame_bottom - 4, global.dialogBG, 0, 0.75 * alpha);
else if (style == 1) Border("draw back", 10, _frame_left, _frame_top);
// else

// Draw the portrait, if there is one.
if (_portrait != NULL) 
{
    BlueFace("begin");
    var portrait_frame_left = _frame_left + 15;
    var portrait_frame_top = _frame_top + 8 + ((_lines - 3) * 5);
    var portrait_left = portrait_frame_left + 8;
    var portrait_top = portrait_frame_top + 10;
    // Portrait frame.
    draw_sprite(global.dialogFrame, 0, portrait_frame_left, portrait_frame_top);
    // Actual portrait.
    draw_sprite(_portrait, 0, portrait_left, portrait_top);
    BlueFace("end");
}

/// Draw the frame. ///
//if (style == 0)
if global.dialogFrame != s_diag_frame &amp;&amp; _boxless = false and _mystery_backdrop = false then 
{
    // Edges...
    // Right.
    draw_spr_tiled(_frame_right - 16, _frame_top + 16, _frame_right, _frame_bottom - 16, global.dialogEdge, 0, alpha);
    // Top.
    draw_spr_tiled(_frame_left + 16, _frame_top , _frame_right - 16, _frame_top + 15, global.dialogEdge, 1, alpha);
    // Left.
    draw_spr_tiled(_frame_left, _frame_top + 8, _frame_left + 15, _frame_bottom - 4, global.dialogEdge, 2, alpha);
    // Bottom.
    draw_spr_tiled(_frame_left + 16, _frame_bottom - 16, _frame_right - 16, _frame_bottom, global.dialogEdge, 3, alpha);
    // Corners...
    var diag_corner_width = sprite_get_width(global.dialogCorner);
    // Top right.
    draw_sprite_ext(global.dialogCorner, 0, _frame_right - diag_corner_width, _frame_top, 1, 1, 0, c_white, alpha);
    // Top left.
    draw_sprite_ext(global.dialogCorner, 1, _frame_left, _frame_top, 1, 1, 0, c_white, alpha);
    // Bottom left.
    draw_sprite_ext(global.dialogCorner, 2, _frame_left, _frame_bottom - diag_corner_width, 1, 1, 0, c_white, alpha);
    // Bottom right.
    draw_sprite_ext(global.dialogCorner, 3, _frame_right - diag_corner_width, _frame_bottom - diag_corner_width, 1, 1, 0, c_white, alpha);
}
else if _boxless = false and _mystery_backdrop = false then 
    Border("draw border", 10, _frame_left, _frame_top);
// else
/// End draw the frame. ///

// Set the font.
draw_set_font(global.fn_2);
draw_set_halign(0);

// Draw the title then the actual choices.
var title_top = _frame_top + 17;
_text_left = _frame_left + 27;
_text_top = title_top + 16;
if (_portrait != NULL) {
    _text_left += sprite_get_width(global.dialogFrame) - 4;
}
draw_set_color(_title_color);
draw_text(_text_left - 1, title_top, _title);
draw_set_color(_text_color);
draw_text(_text_left + sprite_get_width(s_selection_arrow) + 2, _text_top, _draw_text);

// Draw the cursor.
var selection_top = _text_top + _selection_line * 11;
draw_sprite(s_selection_arrow, 0, _text_left + floor(_bob), selection_top);
draw_set_color(_selection_color);
draw_text(_text_left + sprite_get_width(s_selection_arrow) + 2, selection_top, _selection_text);

// Draw the 'more choices' indicator.
_more_choices_left = _frame_left + _width - 24;
_more_choices_up_top = _frame_top + 16;
_more_choices_down_top = _frame_bottom - 24;

if (true) //(image_index mod 16&lt; 8) ///quick thing to make the arrow blink
{
    draw_sprite_ext(s_more, 1, _more_choices_left - 2, _more_choices_up_top + 2 - _bob, 1, 1, 0, _up_arrow_color, _display_up_arrow);
    draw_sprite_ext(s_more, 0, _more_choices_left - 2, _more_choices_down_top + _bob, 1, 1, 0, _down_arrow_color, _display_down_arrow);
}

//Breakout("draw", _selection_line);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
