<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_sentinel_boss</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>EnemyCombatActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////you get all the default variables from EnemyCombatActor
event_inherited();

// Enemy stats
scr_stats_setBaseStat(self, STAT_BASE_HP, 1400);
scr_stats_setBaseStat(self, STAT_BASE_SPEED, 6);
scr_stats_setBaseStat(self, STAT_BASE_RESISTANCE_KNOCKBACK, 999);
scr_stats_setBaseStat(self, STAT_BASE_RESISTANCE_NORMAL, 15);
scr_stats_setBaseStat(self, STAT_BASE_WEIGHT, 40);

pflife = 1400;

scr_stats_rollBaseStats(12, 9, 7, 4, 8, 4);
//scr_stats_rollBaseStats(2, 7, 7, 4, 2, 6); // old
scr_stats_levelUp(12, 0.3, 0.3, 0.2, 0.0, 0.0);

// Enemy configurations
scr_entity_setZHitbox(0, 16);
anim = 0;
animSpd = 0.2;
animStrike = 0;

scr_stats_hook_onHit_userEvent(8);

walkSpd = 1;

deathSound = "cGremlinSmall_death";
damageSound = "cGremlinSmall_grunt";

// Passive and active states
var ark, conf, attack, attacks,guard;
scr_AI_addPassiveState(scr_AI_passive_none);
conf = scr_AI_addActiveState(scr_AI_active_noAI);
ds_map_replace(conf, "stopAtDistance", 32);
ds_map_replace(conf, "turnSpd", 6);

// Create and configure AI switch
/////////////////////setup AI Switch and attacks
_aiswitch = scr_AI_setSwitch(scr_AI_switch_conditions);
ds_map_replace(_aiswitch,"attackInterval",10); ///added interval between every attack
attacks = ds_map_find_value(_aiswitch, "attacks");

///special AI state is swordUp
count = 0;
shooting = 90;
shootTimer = 0;
armedweapon = 0;
alternator = -1;

////WALKING SHOT
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Walking Shot");
ds_map_replace(conf, "beforeTime", 2);
ds_map_replace(conf, "damageTime", 18);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 10); ///twice more likely to use this action
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
ds_map_add(attack, "noRepeat", true);

////WALKING SHOT, AGAIN
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Walking Shot");
ds_map_replace(conf, "beforeTime", 2);
ds_map_replace(conf, "damageTime", 18);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 20); ///action is even more likely if player is far from the sentinel, and it can be repeated then
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
ds_map_add(attack, "distMin", 128);

////STANDING SHOT
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Standing Shot");
ds_map_replace(conf, "beforeTime", 4);
ds_map_replace(conf, "damageTime", 12);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
ds_map_add(attack, "noRepeat", true);

////SPIN SHOT
conf = scr_AI_addAction(scr_AI_action_userEvent);
ds_map_replace(conf, "userEvent", 2);
ds_map_replace(conf, "attackName", "Spin Shot");
ds_map_replace(conf, "beforeTime", 4);
ds_map_replace(conf, "damageTime", 16);
ds_map_replace(conf, "afterTime", 1);
attack = ds_map_create();
ds_map_add(attack, "action", scr_AI_action_userEvent);
ds_map_add(attack, "attackPriority", 5);
ds_map_add(attack, "actionMap", conf);
ds_list_add(attacks, attack);
ds_map_add(attack, "noRepeat", true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

count +=1;

var _dt = dt();

if(count &gt;4)
{////checks for relative direction of hero compared to beam sword
    count = 0;
    pflife = scr_stats_getCurrentStat(id,STAT_CURRENT_HP)/scr_stats_getEffectiveStat(id,STAT_EFFECTIVE_MAX_HP);
    ds_map_replace(_aiswitch,"attackInterval",2+10*pflife); ///added interval between every attack
}

/*
if(blockAngle!=0)
{
    if(blockUp&gt;0)
    {
        blockUp-=1;
        if(blockAngle&gt;0){blockAngle+=5;}
        else{blockAngle-=5;}
    }
    else
    {
        if(blockAngle &gt; _dt){blockAngle-=_dt}else{blockAngle = 0;}
        if(blockAngle &lt; 0-_dt){blockAngle += _dt}else{blockAngle = 0;}
    }
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

///local vars that allow the attack actions to configure the slash collision check at the end of this script:

/*
count = 0;
dirmove = 0;
diraim = 0;
shooting = 90;
*/

var walking = false;
var shooting = false;
var aiming = false;

////THIS HANDLES ALL OF OOZES' ATTACK ACTIONS:
switch(a_attackState)
{
    case "reset": ///reset attack actions' timing vars
        I_atk_evnt_intBefore = ds_map_find_value(conf, "beforeTime");
        I_atk_evnt_intDamage = ds_map_find_value(conf, "damageTime");
        I_atk_evnt_intAfter = ds_map_find_value(conf, "afterTime");
        I_atk_evnt_didAttack = false;
        a_attackAnim = 0;
        a_attackState = "before";
        a_attackSubState = 0;
        shootTimer = 0;
        scr_entity_setMoveXY(0, 0);
        
        if(x&gt;I_AI_target.x+48&amp;&amp;y&lt;I_AI_target.y-48){direction = 225; show_debug_message("top right");}
        else if(x&lt;I_AI_target.x-48&amp;&amp;y&lt;I_AI_target.y-48){direction = 314; show_debug_message("top left");}
        else if(x&lt;I_AI_target.x-48&amp;&amp;y&gt;I_AI_target.y+48){direction = 45; show_debug_message("low left");}
        else if(x&gt;I_AI_target.x+48&amp;&amp;y&gt;I_AI_target.y+48){direction = 135; show_debug_message("low right");}
        else {direction = choose(45,135,225,315); show_debug_message("center");}
        
        armedweapon+=1;
        if(armedweapon&gt;5){armedweapon=0;}
        show_debug_message(string(armedweapon));
        break;
        
    case "before": ///timing before any attack anim
        switch(a_attackName) 
        {
            case "Walking Shot":
                aiming = true;
                break;
                
            case "Standing Shot":
                break;
                     
            case "Spin Shot":
                faceDir = direction - 90;
                break;
        }
        
        if(a_attackAnim&lt;I_atk_evnt_intBefore)
        {
            a_attackAnim+= dt();
        }
        else
        {
            a_attackAnim = 0;
            a_attackState = "damage";
            spawnAtkObj = true;
        }
        break;
        
    case "damage": ///action itself
        switch(a_attackName)
        {
            case "Walking Shot":
                walking = true;
                shooting = true;
                break;
                
            case "Standing Shot":
                aiming = true;
                shooting = true;
                break;
                     
            case "Spin Shot":
                faceDir += 8*dt();
                shooting = true;
                break;
        }
        
        if(a_attackAnim &lt; I_atk_evnt_intDamage)
        {
            a_attackAnim+= dt();
        }
        else
        {
            a_attackAnim = 0;
            a_attackState = "after";
        }
        break;
        
    case "after": ///timing after attack anim
        if (a_attackAnim &lt; I_atk_evnt_intAfter)
        {
            a_attackAnim += dt();
        }
        else
        {
            a_attackState = "reset";
            stateResult = AI_STATERESULT_REMOVE;
        }
        break;
}

if(aiming)
{
    faceDir = point_direction(x,y,I_AI_target.x,I_AI_target.y);
}

if(walking)
{
    var spd = 24*dt();
    move_x = lengthdir_x(spd,direction);
    move_y = lengthdir_y(spd,direction);
}

if(shooting)
{
    shootTimer+=dt();
    switch(armedweapon)
    {
        case 0:
        case 2:
        case 4:
            if(shootTimer&gt;0.6) ///machinegun. Shoots fast bullets alternating from the left or right little machinegun cannon
            {
                shootTimer-=0.6;
                alternator+=1;
                ob = instance_create(x,y,o_enemyAttack_bulletNormal);
                ob.life = 8;
                if(alternator mod 2==0)
                {
                    ob.x = x+lengthdir_x(8,faceDir+90);
                    ob.y = y+lengthdir_y(8,faceDir+90);
                }
                else
                {
                    ob.x = x+lengthdir_x(8,faceDir-90);
                    ob.y = y+lengthdir_y(8,faceDir-90);
                }
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 16);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 2);
                with ob scr_entity_setDirSpd(other.faceDir,32);
                ob.dmg_dir = ob.direction;
                ds_list_copy(ob.target_list, target_list);
            }
            break;
            
        case 1: ////seeker rockets
            if(shootTimer&gt;4)
            {
                shootTimer-=4;
                alternator+=1;
                ob = instance_create(x,y,o_enemy_bullet_destructible_seek);
                ob.life = 8;
                if(alternator mod 2==0) ///shots alternate from the left and right little machinegun cannon
                {
                    ob.x = x+lengthdir_x(32,faceDir+90);
                    ob.y = y+lengthdir_y(32,faceDir+90);
                }
                else
                {
                    ob.x = x+lengthdir_x(32,faceDir-90);
                    ob.y = y+lengthdir_y(32,faceDir-90);
                }
                ob.sprite_index = s_sentinel_missile;
                walkSpd = 2;
                with ob scr_entity_setDirSpd(other.faceDir,20);
            }
            break;
        
        case 3: ////rocket pod
            if(shootTimer&gt;2)
            {
                shootTimer-=2;
                alternator+=1;
                ob = instance_create(x,y,o_enemy_bullet_destructible);
                ob.life = 8;
                if(alternator mod 2==0) ///shots alternate from the left and right little machinegun cannon
                {
                    ob.x = x+lengthdir_x(16,faceDir+90);
                    ob.y = y+lengthdir_y(16,faceDir+90);
                }
                else
                {
                    ob.x = x+lengthdir_x(16,faceDir-90);
                    ob.y = y+lengthdir_y(16,faceDir-90);
                }
                ob.sprite_index = s_sentinel_rocket;
                with ob scr_entity_setDirSpd(other.faceDir,16);
            }
            break;
        
        case 5: ////fire beam
            if(shootTimer&gt;1.2)
            {
                shootTimer-=1.2;
                alternator+=1;
                ob = instance_create(x,y,o_enemyAttack_bullet_fireball);
                ob.life = 8;
                if(alternator mod 2==0) ///shots alternate from the left and right little machinegun cannon
                {
                    ob.x = x+lengthdir_x(12,faceDir+90);
                    ob.y = y+lengthdir_y(12,faceDir+90);
                }
                else
                {
                    ob.x = x+lengthdir_x(12,faceDir-90);
                    ob.y = y+lengthdir_y(12,faceDir-90);
                }
                scr_stats_setAttackStat(ob, STAT_ATTACK_DMG_NORMAL, 24);
                scr_stats_setAttackStat(ob, STAT_ATTACK_KNOCKBACK, 3);
                with ob scr_entity_setDirSpd(other.faceDir,18);
                ob.dmg_dir = ob.direction;
                ds_list_copy(ob.target_list, target_list);
            }
            break;
            
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

draw_sprite_ext(sprite_index,0,dx,dy,1,1,0,c_white,1);

scr_artDebugPlaceholder();

draw_set_alpha(1);
draw_text(x,y+32,"life "+string(pflife*100) + "%");

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>22,49</point>
    <point>28,28</point>
  </PhysicsShapePoints>
</object>
