<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>icon_parent</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>CombatActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited()

// Entity configurations
scr_entity_setZHitbox(0, 18);

// By default, enemies attack only the player
ds_list_add(target_list, PlayerCombatActor);

// Sounds
deathSound = noone;

// References to other instances
damagedFrom = noone;

// Direction the enemy is facing (not moving)
faceDir = random(360);

// Starting position
startPointx = x;
startPointy = y;
startDir = faceDir;

// Lifebar setup
scr_enemy_lifebar("setup");

///CREATURE MAIN PROPERTIES have the s_ suffix
killValue = 1; ///value of kill for gun charge purposes.

// AI States
scr_AI_disable(false);
scr_AI_init();
AI_prepared = false;

// AI Combat Hooks
scr_stats_hook_onStagger(scr_AI_hook_onStagger);
scr_stats_hook_onHit(scr_AI_hook_onHit);

// AI Aggro
scr_AI_aggro_init();

// AI Ammo
AI_ammo = ds_map_create();

// AI Hearing
scr_AI_hearing_setHearingDistanceModifer(1);
scr_AI_hearing_hookScript(NULL);
scr_AI_hearing_hookUserEvent(NULL);

// Default Thinkfluencing value
thinkfluencing = 10; 

// AI Internal variables
I_AI_target = noone; // Currently targeted instance
I_aAI_aiState = ""; // AI states can give info on what they are currenly doing
I_gAI_staggerStr = 0; // Stagger strength
I_AI_brainpoints = 0; // "brain points" for use with AI wait time / "thinkfluencing" value


// Origin where bullets come out, relative to object origin.
p_bulletOx = 0;
p_bulletOy = 0;
p_bulletOz = 16;

//------------------
// Variables used by generic display codes, set by most AI scripts.
a_walking = false;
a_attackName = "";
a_attackState = "";
a_attackAnim = 0;
anim = 0;

// Others
isBlocking = false; ////some AIs set this to true during certain moments. if the enemy has no shield, its ignored.

// Battle Clear - When 1, clear battle mode on death
battleClear = 0;
activeMoveTowardsLand = -999; // Debug movement fix

// Aggro
aggroSmoke = 0;
aggroSmokeSecond = 8;
aggroSmokeColor[0] = merge_color(c_red, c_black, 0.0);
aggroSmokeColor[1] = merge_color(c_red, c_black, 0.33);
aggroSmokeColor[2] = merge_color(c_red, c_black, 0.66);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up resource usage
scr_AI_destroy();
scr_AI_aggro_destroy();
scr_AI_ammo_destroy();
var totKil = Quest("totalKills") + 1;
Quest("totalKills", totKil);

if (battleClear)
{
    battleClear = 0;
    global.tmp = 0;
    with (EnemyCombatActor) global.tmp += battleClear;
    if (global.tmp == 0)
        {
        global.battleMode = 0;
        PEDESTRIAN(1);
        global.gunPacify = instance_exists(o_room_pacify);
        if (global.gunPacify) scr_player_setGunHolstered(true);
        global.alignmentDamageDealt = 1;
        global.alignmentDamageTaken = 1;
        // return drop table to normal probs
        Quest("dropTable", 0);
        }
}

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Default enemy animation
event_inherited();
if paused() exit;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// AI
event_inherited();
if paused() exit;

AI_decisionTimer -= dt();

if (!AI_disabled &amp;&amp; AI_decisionTimer &lt; 0) {
    // === AI management and execution ===
    
    // AI Aggro
    scr_AI_aggro_step()
    
    // AI_target
    I_AI_target = scr_AI_aggro_getTarget()
    
    // Enable AI Switch if stack trace is empty
    if (AI_stateCount &lt;= 0) {
        AI_switchEnabled = true;
    }
    
    // AI Switch
    if (AI_switch &gt;= 0 and AI_switchEnabled) 
    {
        if (!AI_prepared)
        {
            script_execute(AI_switchScript,"reset",AI_switch);
            AI_prepared = true;
        }
        
        // Execute AI Switch
        script_execute(AI_switchScript,"execute",AI_switch);
    }
    
    // AI Current state
    var depth_ = 0;
    var execute = true;
    while (depth_ &lt; AI_stateCount and execute)
    {
        // Execute top AI state. Pop it if it is finished (i.e. returns true)
        var finished;
        var state;
        var prevStateCount = AI_stateCount;
        var statePos = AI_stateCount - 1 - depth_;
        if (depth_ == 0) {
            // Variables for this are already ready - save some performance
            if (AI_stateTop &gt;= 0 and AI_stateTopScript &gt;= 0) {
                state = AI_stateTop;
                finished = script_execute(AI_stateTopScript, "execute", AI_stateTop);
            }
        }
        else {
            state = ds_list_find_value(AI_statestack, statePos);
            finished = scr_AI_executeState(depth_);
        }
        
        // Check if state is to be removed
        if (finished == AI_STATERESULT_REMOVE or
            finished == AI_STATERESULT_FALLTHROUGH_REMOVE)
        {
            // Check if any new states were added
            var diff = ds_list_size(AI_statestack) - prevStateCount;
            // Ensure the state still exists (otherwise it was popped manually)
            if (ds_list_find_value(AI_statestack, statePos) == state) {
                scr_AI_statePop(depth_ + diff);
                depth_--;
            }
            
            // THINKFLUENCING
            // how long does an AI wait between actions?
            
            AI_decisionTimer = AI_decisionFrequency;
        }
        
        // Check if should fallthrough to next state
        if (finished == AI_STATERESULT_FALLTHROUGH or
            finished == AI_STATERESULT_FALLTHROUGH_REMOVE) {
            execute = true;
            depth_++;   
        }
        else {
            execute = false;
        }
    }
}

// Death
if( scr_stats_getCurrentStat(self, STAT_CURRENT_HP) &lt;= 0 )
{
    event_user(9);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="19">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DEATH SCRIPT
if(damagedFrom!= noone &amp;&amp; instance_exists(damagedFrom))
{
    damagedFrom.pChargeKilled +=1;
    damagedFrom.pChargeKilledPow += killValue;
}

audio_play_sound_at_xy(deathSound, false, 90, x, y);

if (scr_stats_getCurrentStat(id, STAT_CURRENT_HP) &lt; 0) {
    Drop("item", dropdata);
}

instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw
event_inherited();

// GZ TEST - Angry at other enemies
var agr = scr_AI_aggro_getTarget();
if (agr != noone &amp;&amp; agr != o_hoopz.id)
{
    var agx = ailmentTotem_core_x;
    var agy = ailmentTotem_core_y - ailmentTotem_head;
    //draw_text(dx + agx, dy + agy - 20, "ENEMYAGGRO");
    //draw_sprite(s_effect_jetpackSmoke, global.DELTA_TOTAL / 150, dx, dy + agy - 20);
    aggroSmoke += dt_sec() * aggroSmokeSecond;
    while (aggroSmoke &gt; 1)
    {
        aggroSmoke -= 1;
        Smoke("customcolor", aggroSmokeColor[0], aggroSmokeColor[1], aggroSmokeColor[2]);
        smk = Smoke("puff keep", dx - 4 + random(8), dy + agy - 0 - 4 + random(8), 0, 34 + random(8));
        //smk.move_x = move_x;
        //smk.move_y = move_y - 12;
        smk.smoke_speed = 2;
        with (smk) { event_user(0); instance_destroy(); }
        Smoke("color", c_white);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
