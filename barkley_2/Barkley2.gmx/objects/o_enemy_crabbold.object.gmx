<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_enemy_crabbold_head</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>EnemyCombatActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup
event_inherited();

/// --- Set standard AI configurations
scr_entity_setZHitbox(0, global.settingEnemyBigHeight);
ailmentTotem_define(id, 0, 0, 0, 0);
scr_enemyDB_statsGet(enemyBuild);

scr_stats_genEffectiveStats();
scr_stats_resetCurrentStats();
            
/// --- Begin with creating all moving parts and their required vars
LEGDIST_X = 6//24;
LEGDIST_Y = 4//18;
STEPDIST = 8;
STEPTIME = 2.5;
STEPHEIGHT_LEGS = 6;
STEPHEIGHT_BODY = 4;
ZHEIGHT_BODY = 10;

leg_x[0] = x - LEGDIST_X;
leg_x[1] = x - LEGDIST_X;
leg_x[2] = x + LEGDIST_X;
leg_x[3] = x + LEGDIST_X;

leg_y[0] = y - LEGDIST_Y;
leg_y[1] = y + LEGDIST_Y;
leg_y[2] = y - LEGDIST_Y;
leg_y[3] = y + LEGDIST_Y;

leg_id[0] = instance_create(leg_x[0], leg_y[0], o_enemy_crabbold_leg);
leg_id[1] = instance_create(leg_x[1], leg_y[1], o_enemy_crabbold_leg);
leg_id[2] = instance_create(leg_x[2], leg_y[2], o_enemy_crabbold_leg);
leg_id[3] = instance_create(leg_x[3], leg_y[3], o_enemy_crabbold_leg);

leg_id[0].image_index = 2*2;
leg_id[1].image_index = 0*2;
leg_id[2].image_index = 3*2;
leg_id[3].image_index = 1*2;

z = 12;

// Define shadows
with (leg_id[0]) scr_entity_setShadowSprite(s_enemy_crabotron_leg_shadow, image_index, 0, 0);
with (leg_id[1]) scr_entity_setShadowSprite(s_enemy_crabotron_leg_shadow, image_index, 0, 0);
with (leg_id[2]) scr_entity_setShadowSprite(s_enemy_crabotron_leg_shadow, image_index, 0, 0);
with (leg_id[3]) scr_entity_setShadowSprite(s_enemy_crabotron_leg_shadow, image_index, 0, 0);
scr_entity_setShadowSprite(s_enemy_crabotron_body_shadow, 0, 0, 0);

// Stance: Stand still
stance = "stand"

// Stance: Step
stepTime = 0;

// Walking vars
body_x_target = 0;
body_y_target = 0;
body_x_prev = 0;
body_y_prev = 0;

leg_switch = false;
prev_dir = -1;

leg_x_target[0] = leg_x[0];
leg_x_target[1] = leg_x[1];
leg_x_target[2] = leg_x[2];
leg_x_target[3] = leg_x[3];

leg_y_target[0] = leg_y[0];
leg_y_target[1] = leg_y[1];
leg_y_target[2] = leg_y[2];
leg_y_target[3] = leg_y[3];

// CombatActor stuff
scr_actor_setActorPushType(ACTOR_COLLISIONPUSH_IMMOBILE);
scr_actor_setActorPushDist(30);
scr_path_setMovementType(scr_path_movementType_determineDirectionOnly);
scr_path_setLookaheadDist(32);
scr_path_setWalldist(56);
scr_entity_setZHitbox(0, 16);

prev_x = x;
prev_y = y;

p_bulletOz = 4;


movement = scr_AI_movement_init(scr_AI_movementType_standard_pathOnly);

switch_conf = scr_AI_setSwitch(scr_AI_switch_standard);
scr_AI_addPassiveState(scr_AI_passive_none);
approach = scr_AI_addActiveState(scr_AI_active_approach);
approach[? "walkScript"] = movement;
approach[? "stopAtDistance"] = 40;

scr_AI_aggro_configure(200, 500, 1400);

// Photon Volcano
photonvolcano_attack = scr_AI_switch_standard("new_attack", switch_conf);
photonvolcano_action = scr_AI_addAction(scr_AI_action_crabotron_photonvolcano);
photonvolcano_attack[? "action"] = photonvolcano_action; 

AI_util_action_setDamage(photonvolcano_action, 0, 0, 0, .5, 0, 10, STAGGER_HARDNESS_SOFT);

photonvolcano_action[? "beforeTime"]= 4; ////time after each shot
photonvolcano_action[? "afterTime"]= 0.4; ////time after each shot
photonvolcano_action[? "closeTime"]= 4; ////time at the end of burst
photonvolcano_action[? "shots"]= 3; ////photon shots repeats
photonvolcano_action[? "speed"]= 8;
photonvolcano_action[? "speedRnd"]= 4;
photonvolcano_action[? "speedZ"]= 14; 
photonvolcano_action[? "speedZRnd"]= 6; 

photonvolcano_attack[? "distMax"] = 220;
photonvolcano_attack[? "cooldownTime"] = 20; 
photonvolcano_attack[? "cooldownTimeRnd"] = 10;
photonvolcano_attack[? "rechargeTime"] = 12;
photonvolcano_attack[? "rechargeTimeRnd"] = 4;
photonvolcano_attack[? "coneAngleMax"] = 180;

// Blink
blink_attack = scr_AI_switch_standard("new_attack", switch_conf);
blink_action = scr_AI_addAction(scr_AI_action_animation);
blink_attack[? "action"] = blink_action; 

blink_action[? "attackName"]= "blink"; ////time after each shot
blink_action[? "time"]= 8; ////time after each shot

blink_attack[? "distMax"] = 220;
blink_attack[? "cooldownTime"] = 60;
blink_attack[? "cooldownTimeRnd"] = 40;
blink_attack[? "rechargeTime"] = 12;
blink_attack[? "rechargeTimeRnd"] = 4;
blink_attack[? "coneAngleMax"] = 180;

/// --- Sounds
sndLegMove = "cGremlinSmall_swipe"; // Should be a hydraulics kind of sound.
sndLegLand = "oildrum_hurt"; // Sound of leg stepping down onto floor. Heavy metal foot hitting metal.
sndChatter = "junkbot_alert"; // Continuous bleeps and bloops while it's chasing player (less frequent when it's not)

sndChatterTimer = 20;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>////Animations

scr_entity_animation_define("headBlink", s_enemy_crabbold_head, 2, 6, 0);
scr_entity_animation_define("headVolcano_before", s_enemy_crabbold_head, 8, 2, 0);
scr_entity_animation_define("headVolcano_attack", s_enemy_crabbold_head, 10, 1, 0);
scr_entity_animation_define("headVolcano_after", s_enemy_crabbold_head, 10, 4, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

/// Destroy legs
for (var i = 0; i &lt; 4; i++) {
    with (leg_id[i]) { instance_destroy(); }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if paused() exit;

// Check if has been moved - if so, update XY coordinates all over the board
if (prev_x != x || prev_y != y) {
    dx = x - prev_x;
    dy = y - prev_y;
    body_x_prev += dx;
    body_y_prev += dy;
    body_x_target += dx;
    body_y_target += dy;
    for (var i = 0; i &lt; 4; i++) {
        leg_x[i] += dx;
        leg_y[i] += dy;
        leg_x_target[i] += dx;
        leg_y_target[i] += dy;
    }
}


/// --- 
move_z = 0;

switch (stance) {
    case "step":
        stepTime = max(0, stepTime - dt());
        var stepRatio = (stepTime / STEPTIME);
        
        // Position body
        x = body_x_prev + ((body_x_target - body_x_prev) * (1 - stepRatio));
        y = body_y_prev + ((body_y_target - body_y_prev) * (1 - stepRatio));
        z = ZHEIGHT_BODY + sin(stepRatio * pi) * STEPHEIGHT_BODY;
        
        // Position legs that are moving
        for (var i = 0; i &lt; 4; i++) {
            if (leg_x[i] != leg_x_target[i] or leg_y[i] != leg_y_target[i]) {
                leg_id[i].x = leg_x[i] + ((leg_x_target[i] - leg_x[i]) * (1 - stepRatio));
                leg_id[i].y = leg_y[i] + ((leg_y_target[i] - leg_y[i]) * (1 - stepRatio));
                leg_id[i].z = sin(stepRatio * pi) * STEPHEIGHT_LEGS;
            }
        }
        
        // End step if steptime is over
        if (stepTime &lt;= 0) {
            audio_play_sound_on_actor(self.id, scr_soundbank_pickSound(sndLegLand), false, 10);
            stance = "stand";
            leg_switch = !leg_switch; // Next time, step with other legs.
            for (var i = 0; i &lt; 4; i++) {
                leg_x[i] = leg_x_target[i];
                leg_y[i] = leg_y_target[i];
                leg_id[i].x = leg_x_target[i];
                leg_id[i].y = leg_y_target[i];
                leg_id[i].z = 0;
            }
        }
        break;
    
    case "stand":
        z = ZHEIGHT_BODY;
    
        // Take a step if any path is active, or if not previously standing still
        if (scr_path_active() or prev_dir != -1) {
            audio_play_sound_on_actor(self.id, scr_soundbank_pickSound(sndLegMove), false, 10);
            stance = "step";
            
            var p_dir;
            if (scr_path_active()) {
                // Make a step in the target direction
                p_dir = round(path_dir/90) * 90;
                
                // Check if this is the same direction I was previously moving, OR the direct opposite.
                var leg_step_dist;
                var body_step_dist;
                if (p_dir == prev_dir) {
                    // It is!
                    leg_step_dist = STEPDIST * 1.5;
                    body_step_dist = STEPDIST * 1;
                    prev_dir = p_dir;
                }
                else if (prev_dir = -1) {
                    // I was previously standing still. My first step must be shorter or my legs will overlap each other.
                    leg_step_dist = STEPDIST * 1;
                    body_step_dist = STEPDIST * 0.5;
                    prev_dir = p_dir;
                }
                else {
                    // It is not the same dir. I must now reset my legs to standard position to be able to change direction.
                    leg_step_dist = STEPDIST * .5;
                    body_step_dist = STEPDIST * .5;
                    p_dir = prev_dir;
                    prev_dir = -1;
                }
            }
            else {
                // Make a step in previous direction and reset legs to standard position
                leg_step_dist = STEPDIST * .5;
                body_step_dist = STEPDIST * .5;
                p_dir = prev_dir;
                prev_dir = -1;
            }
            
            body_x_target = x + lengthdir_x(body_step_dist, p_dir);;
            body_y_target = y + lengthdir_y(body_step_dist, p_dir);;
            body_x_prev = x;
            body_y_prev = y;
            
            // Choose which 2 legs to step with.
            if (leg_switch) {
                leg_x_target[0] = x - LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[0] = y - LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
                
                leg_x_target[3] = x + LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[3] = y + LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
            }
            else {
                leg_x_target[1] = x - LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[1] = y + LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
                
                leg_x_target[2] = x + LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[2] = y - LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
            }
            
            stepTime = STEPTIME;
        }
        break;
        
    default: // Externally controlled
        
        // Position legs
        for (var i = 0; i &lt; 4; i++) {
            leg_id[i].x = leg_x[i];
            leg_id[i].y = leg_y[i];
            leg_id[i].z = z - ZHEIGHT_BODY;
        }
        
        if (AI_stateTopType != AI_STATETYPE_ACTION) {
            // Whatever state controlled me exited without resetting me, I must do it myself.
            stance = "stand";
        }
        break;
}

prev_x = x;
prev_y = y;

// Sporadic chatter sounds
if (AI_stateTopType != AI_STATETYPE_PASSIVE) {
    sndChatterTimer -= dt();
}
else {
    sndChatterTimer -= dt() * .25;
}

if (sndChatterTimer &lt;= 0) {
    audio_play_sound_on_actor(self.id, scr_soundbank_pickSound(sndChatter), false, 10);
    sndChatterTimer = 15 + random(15);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

//scr_draw_spr(sprite_index, 0, dx, dy);
var image = 0;
var eyepos = 0;

if(I_AI_target == noone)
{
    eyepos = 0;
}
else
{
    if(instance_exists(I_AI_target))
    {
        if(point_distance(x,y,I_AI_target.x,I_AI_target.y)&lt;128)
        {
            eyepos = round(point_direction(x,y,I_AI_target.x,I_AI_target.y)/45+2);
            if(eyepos==10){eyepos=2;}
        }
    }
}

switch(a_attackName)
{
    case "photonvolcano":
        switch(a_attackState)
        {
        case "before":
            image = scr_entity_animation_imageByRatio("headVolcano_before", a_attackAnim, I_atk_shot_intBefore);
            break;
            
        case "attack":
            image = scr_entity_animation_imageByRatio("headVolcano_attack", a_attackAnim, I_atk_shot_intAfter);
            break;
        
        case "after":
            image = scr_entity_animation_imageByRatio("headVolcano_after", a_attackAnim, I_atk_shot_intClose);
            break;
        }
        break;
        
    case "blink":
        image = scr_entity_animation_imageByRatio("headBlink", a_attackAnim, I_atk_anim_max);
        break;
        
    case "stagger":
        image = 1;
        eyepos = 1;
        break;
      
    default:
        image = 0;
        break;
}


draw_sprite_ext(s_enemy_crabbold_eyes,eyepos,dx,dy-19,1,1,0,c_white,1);
draw_sprite_ext(s_enemy_crabbold_head,image,dx,dy,1,1,0,c_white,1);

combatActor_draw_post();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
