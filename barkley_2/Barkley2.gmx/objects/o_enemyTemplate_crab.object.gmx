<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>EnemyCombatActor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

/// --- Begin with creating all moving parts and their required vars
LEGDIST_X = 32//24;
LEGDIST_Y = 24//18;
STEPDIST = 30;
STEPTIME = 3.8;
STEPPAUSE = 0;
STEPHEIGHT_LEGS = 16;
STEPHEIGHT_BODY = 6;
ZHEIGHT_BODY = 7;

leg_x[0] = x - LEGDIST_X;
leg_x[1] = x - LEGDIST_X;
leg_x[2] = x + LEGDIST_X;
leg_x[3] = x + LEGDIST_X;

leg_y[0] = y - LEGDIST_Y;
leg_y[1] = y + LEGDIST_Y;
leg_y[2] = y - LEGDIST_Y;
leg_y[3] = y + LEGDIST_Y;

// Create legs manually
/*
leg_id[0] = instance_create(leg_x[0], leg_y[0], o_enemy_crabotron_leg);
leg_id[1] = instance_create(leg_x[1], leg_y[1], o_enemy_crabotron_leg);
leg_id[2] = instance_create(leg_x[2], leg_y[2], o_enemy_crabotron_leg);
leg_id[3] = instance_create(leg_x[3], leg_y[3], o_enemy_crabotron_leg);

leg_id[0].image_index = 2*3;
leg_id[1].image_index = 0*3;
leg_id[2].image_index = 3*3;
leg_id[3].image_index = 1*3;

*/


// Stance: Stand still
stance = "stand"

// Stance: Step
stepTime = 0;

// Walking vars
body_x_target = 0;
body_y_target = 0;
body_x_prev = 0;
body_y_prev = 0;
step_pause = 0;

leg_switch = false;
prev_dir = -1;

leg_x_target[0] = leg_x[0];
leg_x_target[1] = leg_x[1];
leg_x_target[2] = leg_x[2];
leg_x_target[3] = leg_x[3];

leg_y_target[0] = leg_y[0];
leg_y_target[1] = leg_y[1];
leg_y_target[2] = leg_y[2];
leg_y_target[3] = leg_y[3];

prev_x = x;
prev_y = y;

// Combatactor settings
scr_path_setMovementType(scr_path_movementType_determineDirectionOnly);

// Default sounds
sndLegMove = "crab_leg_lift";
sndLegLand = "crab_leg_land";

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

/// Destroy legs
for (var i = 0; i &lt; 4; i++) {
    with (leg_id[i]) { instance_destroy(); }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if paused() exit;

// Check if has been moved - if so, update XY coordinates all over the board
if (prev_x != x || prev_y != y) {
    dx = x - prev_x;
    dy = y - prev_y;
    body_x_prev += dx;
    body_y_prev += dy;
    body_x_target += dx;
    body_y_target += dy;
    for (var i = 0; i &lt; 4; i++) {
        leg_x[i] += dx;
        leg_y[i] += dy;
        leg_x_target[i] += dx;
        leg_y_target[i] += dy;
    }
}


/// --- 
move_z = 0;

switch (stance) {
    case "step":
        stepTime = max(0, stepTime - dt());
        var stepRatio = (stepTime / STEPTIME);
        
        // Position body
        var x_to = body_x_prev + ((body_x_target - body_x_prev) * (1 - stepRatio));
        var y_to = body_y_prev + ((body_y_target - body_y_prev) * (1 - stepRatio));
        var x_delta = x_to - x;
        var y_delta = y_to - y;
        var collided = scr_collision_move_contact_solid(x_delta, y_delta, collision_check);
        
        if (collided) {
            var x_moved = x - prev_x;
            var y_moved = y - prev_y;
            var x_fail = x_moved - x_delta;
            var y_fail = y_moved - y_delta;
            body_x_prev += x_fail;
            body_y_prev += y_fail;
            body_x_target += x_fail;
            body_y_target += y_fail;
            for (var i = 0; i &lt; 4; i++) {
                leg_x[i] += x_fail;
                leg_y[i] += y_fail;
                leg_x_target[i] += x_fail;
                leg_y_target[i] += y_fail;
            }
        }
        
        // Set Z position
        z = ZHEIGHT_BODY + sin(stepRatio * pi) * STEPHEIGHT_BODY;
        
        // Position legs that are moving
        for (var i = 0; i &lt; 4; i++) {
            if (leg_x[i] != leg_x_target[i] or leg_y[i] != leg_y_target[i]) {
                leg_id[i].x = leg_x[i] + ((leg_x_target[i] - leg_x[i]) * (1 - stepRatio));
                leg_id[i].y = leg_y[i] + ((leg_y_target[i] - leg_y[i]) * (1 - stepRatio));
                leg_id[i].z = sin(stepRatio * pi) * STEPHEIGHT_LEGS;
            }
        }
        
        // End step if steptime is over
        if (stepTime &lt;= 0) {
            audio_play_sound_on_actor(self.id, scr_soundbank_pickSound(sndLegLand), false, 10);
            stance = "stand";
            step_pause = 0;
            leg_switch = !leg_switch; // Next time, step with other legs.
            for (var i = 0; i &lt; 4; i++) {
                leg_x[i] = leg_x_target[i];
                leg_y[i] = leg_y_target[i];
                leg_id[i].x = leg_x_target[i];
                leg_id[i].y = leg_y_target[i];
                leg_id[i].z = 0;
            }
        }
        break;
    
    case "stand":
        z = ZHEIGHT_BODY;
        
        // Position legs
        for (var i = 0; i &lt; 4; i++) {
            leg_id[i].x = leg_x[i];
            leg_id[i].y = leg_y[i];
            leg_id[i].z = 0;
        }
    
        // Take a step if any path is active, or if not previously standing still
        step_pause += dt();
        if (step_pause &gt;= STEPPAUSE and (scr_path_active() or prev_dir != -1)) {
            audio_play_sound_on_actor(self.id, scr_soundbank_pickSound(sndLegMove), false, 10);
            stance = "step";
            
            var p_dir;
            if (scr_path_active()) {
                // Make a step in the target direction
                p_dir = round(path_dir/90) * 90;
                
                // Check if this is the same direction I was previously moving, OR the direct opposite.
                var leg_step_dist;
                var body_step_dist;
                if (p_dir == prev_dir) {
                    // It is!
                    leg_step_dist = STEPDIST * 1.5;
                    body_step_dist = STEPDIST * 1;
                    prev_dir = p_dir;
                }
                else if (prev_dir = -1) {
                    // I was previously standing still. My first step must be shorter or my legs will overlap each other.
                    leg_step_dist = STEPDIST * 1;
                    body_step_dist = STEPDIST * 0.5;
                    prev_dir = p_dir;
                }
                else {
                    // It is not the same dir. I must now reset my legs to standard position to be able to change direction.
                    leg_step_dist = STEPDIST * .5;
                    body_step_dist = STEPDIST * .5;
                    p_dir = prev_dir;
                    prev_dir = -1;
                }
            }
            else {
                // Make a step in previous direction and reset legs to standard position
                leg_step_dist = STEPDIST * .5;
                body_step_dist = STEPDIST * .5;
                p_dir = prev_dir;
                prev_dir = -1;
            }
            
            body_x_target = x + lengthdir_x(body_step_dist, p_dir);;
            body_y_target = y + lengthdir_y(body_step_dist, p_dir);;
            body_x_prev = x;
            body_y_prev = y;
            
            // Choose which 2 legs to step with.
            if (leg_switch) {
                leg_x_target[0] = x - LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[0] = y - LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
                
                leg_x_target[3] = x + LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[3] = y + LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
            }
            else {
                leg_x_target[1] = x - LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[1] = y + LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
                
                leg_x_target[2] = x + LEGDIST_X + lengthdir_x(leg_step_dist, p_dir);
                leg_y_target[2] = y - LEGDIST_Y + lengthdir_y(leg_step_dist, p_dir);
            }
            
            stepTime = STEPTIME;
        }
        break;
        
    default: // Externally controlled
        
        // Position legs
        for (var i = 0; i &lt; 4; i++) {
            leg_id[i].x = leg_x[i];
            leg_id[i].y = leg_y[i];
            leg_id[i].z = z - ZHEIGHT_BODY;
        }
        
        if (AI_stateTopType != AI_STATETYPE_ACTION) {
            // Whatever state controlled me exited without resetting me, I must do it myself.
            stance = "stand";
            step_pause = 0;
        }
        break;
}

prev_x = x;
prev_y = y;

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
