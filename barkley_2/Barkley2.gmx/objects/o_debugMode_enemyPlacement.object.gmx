<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2100000</depth>
  <persistent>0</persistent>
  <parentName>o_debugMode</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>show_debug_message("Enemy placement mode created");

global.enemyPlacementMode = true;
with o_camera instance_destroy(); // Destroy all existing cameras

editMode = "add";

initMovex = 0;
initMovey = 0;

iconOver = -1;
menuOver = -1;
paletteOver = -1;
paletteMenuOver = -1;
spawnMenuOver = -1;

_interceptClick = false;

selectedSpawn = NULL;
hoveringSpawn = NULL;

pickingM = false;
pickingMCur = 0;
monsterMenuDepth = -1;

propX = SCREEN_WIDTH*global.screen_scale - 384;
propY = SCREEN_HEIGHT*global.screen_scale - 144;
pcol1 = 6;
pcol2 = 160;
pcol3 = 280;
lsep = 12;
    
paltX = 2;
paltY = SCREEN_HEIGHT*global.screen_scale-120;

menuX = SCREEN_WIDTH*global.screen_scale-42;
menuY = 2;

mbt_held = -1;

copying = false;
dragGo = false;

// Ensure spawn map exists
var roomName = room_get_name(room);
if (!ds_map_exists(global.spawn_maps, roomName)) {
    global.spawn_maps[? roomName] = spawn_map_create();
}

// Palette
paletteChoice = 0;
paletteSize = 6;
paletteDisplaySize = 6;
paletteScroll = 0;
paletteHover = 0;

// Ensure palette entries exist, then store them
var spawnMap = global.spawn_maps[? roomName];

var hues;
hues[0] = c_orange;
hues[1] = c_red;
hues[2] = c_yellow;
hues[3] = c_green;
hues[4] = c_purple;
hues[5] = c_blue;

for (var i = 0; i &lt; paletteSize; i++) {
    var name = "_palette" + string(i);
    if (!spawn_map_hasSpawnPoint(spawnMap, name)) {
        var spawnPoint = spawn_point_create(0, 0, o_enemy_cGremlin_small);
        spawnPoint[? "uuid"] = name;
        spawnPoint[? "hue"] = hues[i];
        spawn_map_addSpawnPoint(spawnMap, spawnPoint);
    }
    palette[i] = spawnMap[? name];
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>show_debug_message("Enemy placement mode destroyed");

global.enemyPlacementMode = false;
instance_create(o_hoopz.x, o_hoopz.y, o_camera_hoopz);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>paused(true);

var roomName = room_get_name(room);

// TODO replace global.SPAWN_RESET with proper spawn clear

var _cx,_cy,_modified;
_modified = false;

if(pickingM)
{
    var _size;
    if(monsterMenuDepth == -1){_size = ds_list_size(global.eTypeList);}
    else{_size = ds_list_size(monsterMenuDepth);}
                
    if(keyboard_check_pressed(ord('W')))
    {
        pickingMCur -=1;
    }
    
    if(keyboard_check_pressed(ord('S')))
    {
        pickingMCur +=1;
    }
    
    if(keyboard_check_pressed(ord('R')))
    {
        if(monsterMenuDepth == -1){pickingM = false;}
        else{pickingMCur = ds_list_find_index(global.eTypeList,monsterMenuDepth); monsterMenuDepth = -1;}
    }
    
    if(pickingMCur&lt;0){pickingMCur = _size -1;}
    if(pickingMCur&gt;=_size){pickingMCur = 0;}
    
    if(keyboard_check_pressed(ord('E')))
    {
        if(monsterMenuDepth == -1){monsterMenuDepth = ds_list_find_value(global.eTypeList,pickingMCur); pickingMCur = 0;}
        else
        {
            selectedSpawn[? "objectName"] = object_get_name(ds_list_find_value(monsterMenuDepth,pickingMCur));
            pickingM = false;
            _modified = true;
        }
    }
    
}
else
{
    o_curs.visible = false;
    
    _cx = o_curs.x*global.screen_scale;
    _cy = o_curs.y*global.screen_scale;
    
    if(_cy&lt;54 &amp;&amp; _cx&lt;184)/////if hovering the edit icons on top left
    {
        iconOver = (_cx-2) div 30;
    
        if(mouse_check_button_pressed(mb_left))
        {
            _interceptClick = true;
            copying = false;
            switch(iconOver)
            {
                case 0: editMode = "add"; break;
                case 1: editMode = "del"; break;
                case 2: break;
                case 3: break;
                case 4: editMode = "hoopz"; break;
                case 5: editMode = "create"; break;
            }
        }
    }
    else{iconOver = -1;}

    ///////PALETTE PANEL
    if mouse_wheel_up()
    {
        paletteChoice+=1
        if(paletteChoice&gt;=paletteSize){paletteChoice = 0;}
    }
    if mouse_wheel_down()
    {
        paletteChoice-=1;
        if(paletteChoice&lt;0){paletteChoice = paletteSize-1;}
    }
    
    paletteScroll = median(0,paletteSize-paletteDisplaySize,paletteChoice-2);
    
    if(_cx&lt;paltX+(80*paletteSize) &amp;&amp; _cy&gt;paltY &amp;&amp; _cy&lt;paltY+100)
    {
        paletteHover =  (_cx - paltX) div 80 + paletteScroll;
        if(mouse_check_button_pressed(mb_left))
        {
            _interceptClick = true;
            paletteChoice = paletteHover;
            selectedSpawn = palette[paletteChoice];
        }
    }
    else
    {
        paletteHover = -1;
    }

    

    ///////MENU PANEL
    if(_cx&gt;menuX &amp;&amp; _cy &lt;menuY+100)/////if hovering the menu items on top right
    {
        menuOver = (_cy-2) div 20;
        if(mouse_check_button_pressed(mb_left))
        {
            _interceptClick = true;
            switch(menuOver)
            {
                case 0:
                    spawn_map_save(roomName, global.spawn_maps[? roomName]);
                    break;
                    
                case 1:
                    spawn_map_load(roomName);
                    break;
                    
                case 2: break; ////warp to another map
                
                case 3:
                    global.enemyPlacementMode = false;
                    break;
                    
                case 4:
                    with (EnemyCombatActor) {instance_destroy();}
                    with (DestructibleCombatActor) {instance_destroy();}
                    break;
            }
        }
    }
    else{menuOver = -1;}

    /////PROPERTIES PANEL
    if(_cx&gt;propX &amp;&amp; _cy&gt;propY-8)
    {
        if(_cy&lt;propY+12)
        {
            if(_cx&lt;propX+24){spawnMenuOver = 100;}
            else if(_cx&lt;propX + 48){spawnMenuOver = 101;}
            else{spawnMenuOver = 102;}
        }
        else
        {
            if(_cx&lt;propX+pcol2-8) ///in Col 1
            {
                spawnMenuOver = median(0,2,((_cy+3) - propY - lsep) div (lsep*2));
            }
            else if(_cx&gt;propX+pcol3-8)///in Col 3
            {
                spawnMenuOver = 13 + median(0,12,((_cy+3) - propY - lsep) div lsep);
            }
            else ///in Col 2
            {
                spawnMenuOver = 3 + median(0,10,((_cy+3) - propY - lsep) div lsep);
            }
        }
        
        if(mouse_check_button_pressed(mb_left) &amp;&amp; selectedSpawn != NULL)
        {
            if (hoveringSpawn != NULL)
            {
                 selectedSpawn = hoveringSpawn;
            }
            else
            {
                _interceptClick = true;
                copying = false;
                var obj;
                obj = selectedSpawn;
                switch(spawnMenuOver)
                {
                    case 1:
                        selectedSpawn[? "level"] = get_integer("Monster level?",selectedSpawn[? "level"]);
                        break;
                        
                    case 2: // Pick monster type
                        pickingM = true;
                        break;
                        
                    case 3:
                        selectedSpawn[? "build"] = get_string("Monster BUILD name?",selectedSpawn[? "build"]);
                        break;
                        
                    case 4:
                        selectedSpawn[? "resources"] = get_string("How many spawns from this point?",selectedSpawn[? "resources"]);
                        break;
                        
                    case 101:
                        selectedSpawn[? "hue"] = get_integer('Enter Color Value', selectedSpawn[? "hue"]);
                        break;
                }
                with(obj){event_user(0);}
                _modified = true;
            }
        }
    }
    else
    {
        spawnMenuOver = -1;
    }
    
    ///////DRAG AND MOVE SPAWN POINTS
    if(mbt_held&gt;=0 &amp;&amp; dragGo)
    {
        if(mbt_held &gt;12 &amp;&amp; editMode == "add" &amp;&amp; selectedSpawn != NULL)
        {
            selectedSpawn[? "x"] = o_curs.x + view_xview;
            selectedSpawn[? "y"] = o_curs.y + view_yview;
        }
        mbt_held +=1;
    }
    
    if(mouse_check_button_released(mb_left))
    {
        if(mbt_held &gt;12 &amp;&amp; editMode == "add" &amp;&amp; selectedSpawn != NULL) ///was it a proper dragging?
        {
            if(paletteHover != -1) ///were you dragging it into the palette?
            {
                var newSpawn = spawn_point_duplicate(selectedSpawn);
                spawn_map_addSpawnPoint(global.spawn_maps[? roomName], newSpawn);
                newSpawn[? "x"] = initMovex;
                newSpawn[? "y"] = initMovey;
            }
            else
            {
                selectedSpawn[? "x"] = o_curs.x + view_xview;
                selectedSpawn[? "y"] = o_curs.y + view_yview;
                _modified = true;
            }
        }

        mbt_held = -1;
        _interceptClick = true;
    }
    
    
    

    if(!_interceptClick)
    {
        if(mouse_check_button_pressed(mb_left))
        {
            mbt_held = 0;
            
            if(copying)
            {
                if(hoveringSpawn != NULL)
                {
                    selectedSpawn = hoveringSpawn;
                    copying = false;
                    dragGo = true;
                    initMovex = selectedSpawn[? "x"];
                    initMovey = selectedSpawn[? "y"];
                }
                else
                {
                    var new = spawn_point_duplicate(selectedSpawn);
                    spawn_map_addSpawnPoint(global.spawn_maps[? roomName], new);
                    selectedSpawn = new;
                    new[? "x"] = o_curs.x + view_xview;
                    new[? "y"] = o_curs.y + view_yview;
                    _modified = true;
                }
            }
            else
            {
                dragGo = false;
                switch(editMode)
                {
                    case "add":
                        if(hoveringSpawn != NULL)
                        {
                            selectedSpawn = hoveringSpawn;
                            dragGo = true;
                            initMovex = selectedSpawn[? "x"];
                            initMovey = selectedSpawn[? "y"];
                        }
                        else
                        {
                            var new = spawn_point_duplicate(palette[paletteChoice]);
                            spawn_map_addSpawnPoint(global.spawn_maps[? roomName], new);
                            selectedSpawn = new;
                            new[? "x"] = o_curs.x + view_xview;
                            new[? "y"] = o_curs.y + view_yview;
                            _modified = true;
                        }
                        break;
                        
                    case "del":
                        if(hoveringSpawn != NULL)
                        {
                            if(hoveringSpawn == selectedSpawn){selectedSpawn = NULL;}
                            spawn_map_deleteSpawnPoint(global.spawn_maps[? roomName], hoveringSpawn[? "uuid"]);
                            hoveringSpawn = NULL;
                            _modified = true;
                        }
                        break;
                        
                    case "hoopz":
                        o_hoopz.x = o_curs.x+view_xview;
                        o_hoopz.y = o_curs.y+view_yview;
                        break;
                    
                    case "create":
                        var objectName = ds_map_find_value(palette[paletteChoice], "objectName");
                        var objectIndex = assetOrNull(objectName, asset_object);
                        if (objectIndex != NULL) {
                            instance_create(o_curs.x + view_xview,o_curs.y + view_yview, objectIndex);
                        }
                        break;
                }

            }
        }
    }
    

    hoveringSpawn = spawn_map_getClosestSpawnPoint(global.spawn_maps[? roomName], o_curs.x + view_xview, o_curs.y + view_yview, 8);
    
    if(!_interceptClick)
    {
        if(mouse_check_button_pressed(mb_right))
        {
            switch(editMode)
            {
                case "add":
                case "del":
                case "edit":
                case "hoopz":
                    if(hoveringSpawn != NULL){selectedSpawn = hoveringSpawn; copying = true; _interceptClick = true;}
                    else{selectedSpawn = NULL; copying = false;}
                    break;
            }
        }
    }
    
    if(mouse_check_button_released(mb_right)||mouse_check_button_released(mb_left))
    {
        _interceptClick = false;
    }
    
    ////MOVE VIEW AROUND WITH THE GAME CONTROLS
    nx = keyboard_check(ord("D")) - keyboard_check(ord("A"))
    ny = keyboard_check(ord("S")) - keyboard_check(ord("W"))     
    spd = 3;
    x += nx * spd;
    y += ny * spd;
    
    rx = x
    ry = y
    
    x = round(x)
    y = round(y)
    
    // view
    view_xview = x + 8 - view_wview/2
    view_yview = y + 8 - view_hview/2
}

if(_modified)
{
    spawn_map_save(roomName, global.spawn_maps[? roomName]);
    global.SPAWN_RESET = true;
}

if (instance_exists(o_camera_hoopz))
    with o_camera_hoopz instance_destroy();



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw menu

draw_set_color(c_white);
draw_set_alpha(1);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_blend_mode(bm_normal);

var _centerX, _centerY, _boxW, _boxH, _eBoxX, _eBoxY;

_centerX = SCREEN_WIDTH*global.screen_scale/2;
_centerY = SCREEN_HEIGHT*global.screen_scale/2;

_eBoxX = 48*global.screen_scale;
_eBoxY = 32*global.screen_scale;
_eBoxSize = 8*global.screen_scale;

_boxW = SCREEN_WIDTH*global.screen_scale;
_boxH = SCREEN_HEIGHT*global.screen_scale;
draw_set_color(c_white);
draw_set_alpha(0.5);
draw_rectangle(_centerX-_boxW/2,_centerY-_boxH/2,_centerX+_boxW/2,_centerY+_boxH/2,true)

draw_set_alpha(1);
draw_set_color(c_black);
var _col, alpha,_txt,_drawArrow;
_drawArrow = false;
_txt = "";

////EDIT MODE BUTTONS
if(iconOver==0){alpha= 1; _txt = "add spawn point (Z)";}else{alpha = 0.8;}
if(editMode == "add"){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Icon,0,2,22,1,1,0,_col,alpha);

if(iconOver==1){alpha= 1; _txt = "delete spawn point(X)";}else{alpha = 0.8;}
if(editMode == "del"){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Icon,1,32,22,1,1,0,_col,alpha);

if(iconOver==4){alpha= 1; _txt = "move hoopz";}else{alpha = 0.8;}
if(editMode == "hoopz"){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Icon,4,122,22,1,1,0,_col,alpha);

if(iconOver&gt;=5){alpha= 1; _txt = "create object";}else{alpha = 0.8;}
if(editMode == "create"){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Icon,5,152,22,1,1,0,_col,alpha);

if(iconOver != -1)
{
    draw_set_color(c_black);
    draw_rectangle(2,54,54,64,false);
    draw_set_color(c_white);
    draw_text(3,55,_txt);
    
    _drawArrow = true;
}


////MAIN MENU BUTTONS
if(menuOver==0){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Menu,0,menuX,menuY,1,1,0,_col,1);
if(menuOver==1){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Menu,1,menuX,menuY+18,1,1,0,_col,1);
if(menuOver==2){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Menu,2,menuX,menuY+36,1,1,0,_col,1);
if(menuOver==3){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Menu,3,menuX,menuY+54,1,1,0,_col,1);
if(menuOver==4){_col = c_yellow;}else{_col = c_white;}
draw_sprite_ext(s_spawnEdit_Menu,4,menuX,menuY+72,1,1,0,_col,1);

if(menuOver !=-1)
{
    _drawArrow = true;
}


draw_set_color(c_black);

////bottom boxes    
draw_rectangle(propX,propY-12,propX+384,propY+140,false);

draw_rectangle(paltX,paltY,paltX+(80*paletteDisplaySize),paltY+119,false);
draw_rectangle(paltX,paltY+121,paltX+380,paltY+140,false);

////PALETTE BOX
var _i,_palOffsetX,_palCount,pal,_palSpacing,alpha;
_palCount = 0;
draw_set_font(global.fn_small);
_palSpacing = 76;
for(_i = paletteScroll; _i&lt;paletteDisplaySize+paletteScroll; _i+=1)
{
    pal = palette[_i];
    
    if(paletteChoice == _i) {
        draw_set_color(c_white);
        alpha = 1;
    } else {
        draw_set_color(c_gray);
        alpha = 0.6
    }
    pal[? "x"] = paltX+40+_palCount*_palSpacing;
    pal[? "y"] = paltY+32;
    spawn_point_draw(pal, true);
    draw_text(paltX+2+_palCount*_palSpacing, paltY+44, string_replace(pal[? "objectName"], "o_enemy_", ""));
    
    _propsDis = 60;
    draw_text(paltX+2+_palCount*_palSpacing, paltY+_propsDis+ 0, "lvl: " + string(pal[? "level"]));
    draw_text(paltX+2+_palCount*_palSpacing, paltY+_propsDis+10, "build: " + string(pal[? "build"]));
    draw_text(paltX+2+_palCount*_palSpacing, paltY+_propsDis+20, "resources: " + string(pal[? "resources"]));
    
    if(paletteHover == _i)
    {
        draw_set_alpha(1);
        draw_set_color(c_white);
        draw_rectangle(paltX-2+_palCount*_palSpacing,paltY+1,paltX+(_palCount+1)*_palSpacing,paltY+98,true);
    }
    
    _palCount +=1;
}

if(paletteHover != -1)
{
    _drawArrow = true;
}

////SPAWN PROPERTIES BOX
if(selectedSpawn != NULL || hoveringSpawn != NULL)
{
    var _sel,colHover,colNorm,_selcol,_iconCol,alpha;
    colHoverProperty = c_red;
    colHover = c_white;
    colNorm = c_ltgray;
    _selcol = c_white;
    draw_set_color(c_white);
    
    _sel = selectedSpawn;
    if(selectedSpawn == NULL){_sel = hoveringSpawn;}
    
    draw_set_font(global.fn_small);
    if(copying)
    {
        _selcol = c_aqua;
        draw_text((_sel[? "x"]-view_xview-12)*global.screen_scale+2,(_sel[? "y"]-view_yview-14)*global.screen_scale,"(COPYING)");
    }
    
    _iconCol = _sel[? "hue"];
    draw_set_color(_iconCol);
    draw_sprite_ext(s_spawnSelect,0,(_sel[? "x"]-view_xview)*global.screen_scale+2,(_sel[? "y"]-view_yview)*global.screen_scale,global.screen_scale,global.screen_scale,0,_selcol,1);
    
    if(spawnMenuOver ==100){alpha = 1;}else{alpha = 0.7;}
    draw_sprite_ext(s_spawn,0,propX+12,propY,1,1,270,_iconCol,alpha);
    
    if(spawnMenuOver ==101){draw_set_alpha(1);}else{draw_set_alpha(0.7);}
    draw_rectangle(propX+24,propY-8,propX+24+20,propY+6,false);
    draw_line(propX+24+21,propY+6,propX+382,propY+6);
    
    draw_set_alpha(1);
    if(spawnMenuOver==102){draw_set_color(colHover);}else{{draw_set_color(colNorm);}}
    draw_text(propX+48,propY-4,_sel[? "objectName"]);
    
    draw_set_color(colNorm);
    if(!array_contains(palette, _sel)) {draw_text(propX+280,propY-4,"SPAWN INDEX: " + string(_sel[? "uuid"]));}
    else {draw_text(propX+280,propY-4,"PALETTE SPAWN");}
    
    
    if(spawnMenuOver==0){draw_set_color(colHover);}else{{draw_set_color(colNorm);}}
    draw_text(propX+pcol1   ,propY+0+lsep   ,"SPAWN MONSTER: #"     +_sel[? "objectName"]);
    if(spawnMenuOver==1){draw_set_color(colHover);}else{{draw_set_color(colNorm);}}
    draw_text(propX+pcol1   ,propY+0+lsep*3 ,"level: " + string(_sel[? "level"]));
    
    if(spawnMenuOver==2){draw_set_color(colHover);}else{{draw_set_color(c_dkgray);}}
    draw_rectangle(propX+pcol1,propY+0+lsep*4+8,propX+pcol1+140,propY+0+lsep*4+90,true);
    
    var objectIndex = assetOrNull(_sel[? "objectName"], asset_object);
    if (objectIndex != NULL) {
        var objectSprite = object_get_sprite(objectIndex);
        if (objectSprite != NULL) {
            draw_sprite(objectSprite,0,propX+80,propY+120);
        }
    }
    
    if(spawnMenuOver==3){draw_set_color(colHoverProperty);}else{{draw_set_color(colNorm);}}
    draw_text(propX+pcol2   ,propY+0+lsep*1 ,"build: "       +string(_sel[? "build"]));
    if(spawnMenuOver==4){draw_set_color(colHoverProperty);}else{{draw_set_color(colNorm);}}
    draw_text(propX+pcol2   ,propY+0+lsep*2 ,"spawn count: " +string(_sel[? "resources"]));
}

if(spawnMenuOver != -1)
{
    _drawArrow = true;
}

//////EDITOR CURSOR DISPLAYS
///draw spawn mode cursor
if(_drawArrow)
{
    draw_sprite_ext(s_spawnEdit_Cursors,5,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
}
else if(copying)
{
    if(mbt_held&gt;12)
    {
        draw_sprite_ext(s_spawnEdit_Cursors,4,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
    }
    else
    {
        if(hoveringSpawn!=NULL)
        {
            draw_sprite_ext(s_spawnEdit_Cursors,2,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
        }
        else
        {
            draw_sprite_ext(s_spawnEdit_Cursors,6,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
        }
    }
}
else
{
    switch(editMode)
    {
        case "add":
            if(mbt_held&gt;12)
            {
                draw_sprite_ext(s_spawnEdit_Cursors,4,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
            }
            else
            {
                if(hoveringSpawn!=NULL)
                {
                    draw_sprite_ext(s_spawnEdit_Cursors,2,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
                }
                else
                {
                    draw_sprite_ext(s_spawnEdit_Cursors,0,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
                }
            }
            break;
            
        case "del":
            draw_sprite_ext(s_spawnEdit_Cursors,1,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
            break;
            
        case "hoopz":
            draw_sprite_ext(s_spawnEdit_Cursors,3,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
            break;
            
        case "fullwall":
            draw_sprite_ext(s_1,0,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,16,16,0,c_green,0.5);
            draw_sprite_ext(s_spawnEdit_Cursors,0,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
            break;
        
        case "semisolids":
            draw_sprite_ext(s_drum01,0,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,1,1,0,c_green,0.5);
            draw_sprite_ext(s_spawnEdit_Cursors,0,o_curs.x*global.screen_scale div 1,o_curs.y*global.screen_scale div 1,global.screen_scale,global.screen_scale,0,c_white,1);
            break;
    }
}

if(pickingM)
{
    var _i,_s,__obj;
    _s = 0;
    
    draw_set_color(c_black);
    draw_rectangle(_eBoxX-4,_eBoxY-30,_eBoxX+200,_eBoxY-8,false);
        
    draw_set_color(c_white);
    if(monsterMenuDepth==-1)
    {
        draw_text(_eBoxX+8,_eBoxY-26,"PICK A MONSTER CATEGORY");
        draw_text(_eBoxX+8,_eBoxY-18,"W and S move the cursor, E confirms, R to go back.");
        
        for(_i =max(pickingMCur-4,0) ; _i&lt; min(pickingMCur+_eBoxSize,ds_list_size(global.eTypeList)); _i+=1)
        {
            draw_set_color(c_black);
            draw_rectangle(_eBoxX-2,_eBoxY-2+30*_s,_eBoxX+200,_eBoxY+20+30*_s,false);
            
            draw_set_color(c_ltgray);
            if(_i == pickingMCur)
            {
                draw_rectangle(_eBoxX-2,_eBoxY-2+30*_s,_eBoxX+200,_eBoxY+20+30*_s,true);
                draw_set_color(c_white);
            }
            
            draw_sprite(ds_list_find_value(global.eTypeIcon,_i),0,_eBoxX+16,_eBoxY+16+30*_s);
            draw_text(_eBoxX+32,_eBoxY+4+30*_s,ds_list_find_value(global.eTypeName,_i));
            _s +=1;
        }
    }
    else
    {
        draw_text(_eBoxX+8,_eBoxY-26,"PICK THE MONSTER TO SPAWN");
        draw_text(_eBoxX+8,_eBoxY-18,"W and S move the cursor, E confirms, R to go back.");
        
        for(_i =max(pickingMCur-4,0) ; _i&lt; min(pickingMCur+_eBoxSize,ds_list_size(monsterMenuDepth)); _i+=1)
        {
            draw_set_color(c_black);
            draw_rectangle(_eBoxX-2,_eBoxY-2+30*_s,_eBoxX+200,_eBoxY+20+30*_s,false);
            
            draw_set_color(c_ltgray);
            if(_i == pickingMCur)
            {
                draw_rectangle(_eBoxX-2,_eBoxY-2+30*_s,_eBoxX+200,_eBoxY+20+30*_s,true);
                draw_set_color(c_white);
            }
            
            __obj = ds_list_find_value(monsterMenuDepth,_i);
            draw_sprite(object_get_sprite(__obj),0,_eBoxX+16,_eBoxY+16+30*_s);
            draw_text(_eBoxX+32,_eBoxY+4+30*_s,object_get_name(__obj));
            _s +=1;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw spawn points

var roomName = room_get_name(room);
spawn_map_draw(global.spawn_maps[? roomName]);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
