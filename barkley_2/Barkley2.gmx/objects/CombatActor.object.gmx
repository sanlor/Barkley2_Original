<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>icon_parent</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Actor</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create default status objects
event_inherited()

// === Event Hooks ===
displaysDamage = true;

// === Knockback Vector (Knockback strength stored in Current stats) ===
knockback_vector_x = 0;
knockback_vector_y = 0;
scr_stats_knockback_setKnockbackHandler(scr_stats_knockbackHandler_standard)

// === Local variables ===
invulnerable = false;
targetable = true;
is_blocking = false;
lastDmg = 0;
isGooped = -999;

// GLAMP and resistance bars, draw or not? // True by default //
resistancedraw = true;
glampdraw = true;

// === Pushback type ===
collisionPush = ACTOR_COLLISIONPUSH_STANDARD;
collisionPushDist = 2;

// === Hooks ===
scr_stats_hook_onStagger(NULL);
scr_stats_hook_onStagger_userEvent(NULL);

scr_stats_hook_onKnockback(NULL);

scr_stats_hook_onHit(NULL);
scr_stats_hook_onHit_userEvent(NULL);

hook_hitfx = NULL;

scr_stats_hook_onDamage(NULL);

scr_stats_hook_onInstantKill(NULL);

scr_stats_hook_genEffectiveStats(scr_stats_genEffectiveStats);

// === Items / Equipment ===

// === Status effects ===
// Create status effects list
list_status_effect = ds_list_create();

// == Stats ==
scr_stats_initStats();

// == Resistances Show ==

//Check for showing resistances at the bottom, if it's higher than 0 it'll decrease to it,
//Triggers on being hit by a bullet
resistance_show = 0;

// Ailment totem coordinates // Values used to be 0 12 24
ailmentTotem_define(self.id, 0, sprite_height * 0.5, sprite_height * 1.25, 24);

// Start up lifebar
if object_get_name(object_index) != "o_hoopz" then scr_enemy_lifebar("setup");

// Hit flash //
hit_flash_str = 0;
hit_flash_timer = 0;
hit_flash_time = 1;
hit_flash_color = c_white;

// Render surface
render_surf_size = 128;

// Read current spawn point
spawnPoint = global.currentSpawnPoint;

// Build type
if (spawnPoint != NULL) {
    enemyBuild = spawnPoint[? "build"];
    if (is_undefined(enemyBuild)) {
        enemyBuild = "default";
    }
} else {
    enemyBuild = "default";
}
//show_debug

dropdata = ds_map_create();
Drop("fixed", NULL);
Drop("enabled", true);

// Target list
target_list = ds_list_create();

// Immunity
statusEffect_immunity_init();

// Sounds
damageSound = NULL_STRING;

// == Can Wade ==
can_wade = true; //True = Submerge into Wading tiles fine, False = Drown on touching water
wadeSplash = true; // Splash when going to water, false for flying stuff
spriteHue = 0;
spriteHueDid = 0;

// Apply wading if the actor is already colliding with a wading tile
if(instance_exists(o_wading_area))
{
    if (not scr_collision_point_free(x, y, 0, COLLISION_WADING) &amp;&amp;
        z &lt;= base_z)
    {
        var script = ds_map_find_value(o_wading_area.wadingEffect, "script");
        if (!statusEffect_immunity_isImmune(id, script)) {
            script_execute(script, o_wading_area.wadingEffect, id, "apply");
        }
    }
}

// Hit by periodic
periodicHit = 0;
periodicTime = 1; // Time in seconds to flash periodic
periodicColor = c_bio; // Not sure if used
prefixDropAmmo = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up resource usage
if (!object_is_ancestor(object_index, PlayerCombatActor)) {
    ds_map_destroy(stats_base);
    ds_map_destroy(stats_effective);
    ds_map_destroy(stats_current);
    
    while (ds_list_size(list_status_effect) &gt; 0) {
        var m = ds_list_find_value(list_status_effect, 0);
        ds_map_destroy(m);
        ds_list_delete(list_status_effect, 0);
    }
    ds_list_destroy(list_status_effect);
}

ds_list_destroy(target_list);
ds_map_destroy(dropdata);

statusEffect_immunity_destroy();

event_inherited();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update Effective and Current Stats, apply Status effects
event_inherited();
if paused() exit;

if (ds_list_size(list_status_effect) &gt; 0) {
    script_execute(hook_genEffectiveStats_script);
    doGenEffectiveStats = true;
} else if (doGenEffectiveStats == true) {
    script_execute(hook_genEffectiveStats_script);
    doGenEffectiveStats = false;
}
scr_stats_stepCombatActor();

if object_get_name(object_index) != "o_hoopz" then scr_enemy_lifebar("step");

hit_flash_timer = max(0, hit_flash_timer - dt());

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle Knockback
event_inherited();
if paused() exit;

script_execute(knockback_handler)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="CombatActor">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if paused() exit;

var cp1 = collisionPush
var cp2 = other.collisionPush
if (cp1 != ACTOR_COLLISIONPUSH_NONE &amp;&amp;
        cp2 != ACTOR_COLLISIONPUSH_NONE &amp;&amp;
        !(cp1 == ACTOR_COLLISIONPUSH_IMMOBILE) &amp;&amp;
        scr_entity_zcollision(id, other.id)) {
    var pushdir = point_direction(other.x, other.y, x, y);
    var pushdist = other.collisionPushDist * dt();
    // Push max 1pixel at a time
    while (pushdist &gt; 0 &amp;&amp; place_meeting(x, y, other.id)) {
        var d = min(pushdist, 1);
        scr_collision_move_contact_solid(lengthdir_x(d, pushdir), lengthdir_y(d, pushdir), collision_check);
        pushdist -= d;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

// Call draw event from status effects
ailmentTotem_headqueue_reset(self.id);
for (var i = 0; i &lt; ds_list_size(list_status_effect); i += 1) {
    var map, scr;
    map = ds_list_find_value(list_status_effect, i);
    scr = ds_map_find_value(map, "script");
    script_execute(scr, map, self.id, "draw", NULL);
}
   
// Render enemy to surface
// GZ added periodic here
doRenderSurf = (periodicHit &gt; 0) or (ds_list_size(list_status_effect) &gt; 0) or (
        hit_flash_str &gt; 0 and hit_flash_timer &gt; 0 and hit_flash_time &gt; 0);
if (doRenderSurf) {
    if (render_surf_size == 256) {
        if (!surface_exists(global.combatactor_surf_256)) {
            global.combatactor_surf_256 = surface_create(256, 256);
        }
        renderSurf = global.combatactor_surf_256;
    } else if (render_surf_size == 128) {
        if (!surface_exists(global.combatactor_surf_128)) {
            global.combatactor_surf_128 = surface_create(128, 128);
        }
        renderSurf = global.combatactor_surf_128;
    } else if (render_surf_size == 64) {
        if (!surface_exists(global.combatactor_surf_64)) {
            global.combatactor_surf_64 = surface_create(64, 64);
        }
        renderSurf = global.combatactor_surf_64;
    } else if (render_surf_size == 32) {
        if (!surface_exists(global.combatactor_surf_32)) {
            global.combatactor_surf_32 = surface_create(32, 32);
        }
        renderSurf = global.combatactor_surf_32;
    } else {
        show_error("Invalid CombatActor render surface size: " + string(render_surf_size), true);
    }
    
    surface_set_target(renderSurf);
    draw_clear_alpha(c_black, 0.0);
    dxReal = dx;
    dyReal = dy;
    dx = render_surf_size * 0.50;
    dy = render_surf_size * 0.75;
}

if (spriteHue != 0)
{
    shader_set(shader_hue);
    shader_set_uniform_f(shader_get_uniform(shader_hue, "argHue"), spriteHue);
    spriteHueDid = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
