<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Entity</parentName>
  <maskName>mask_disk_20by20</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited()

scr_entity_setShadowVisible(false);

// All below are set in ZauberBallSucker
movement_direction = 0;
movement_speed = 5;
movement_distance_remain = 50;
radius_outer = 32;
radius_outer_max = 96;
radius_growth_speed = 4;

/// Extra
activation_timer = 0.5;
radius_inner = 8;
pull_dist = 12;
pull_strength = 25;
timeSucking = 6;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Step
event_inherited();
if paused() exit;

if (instance_exists(kid))
{
    kid.x = x;
    kid.y = y;
}

if (movement_distance_remain &lt;= 0) 
{
    kid.stopped = 1;
    scr_entity_setDirSpd(0, 0);
    timeSucking -= dt_sec();
    // Grow in size
    radius_outer = min(radius_outer_max, radius_outer + (radius_growth_speed * dt_sec()));
    
    
    if (timeSucking &lt;= 0) { instance_destroy(); exit; }
}
else
{
    scr_entity_setDirSpd(movement_direction, movement_speed);
    scr_entity_bounceOnCollide(0.75);
    movement_direction = move_dir; // Update in case of wall bounce
    movement_distance_remain -= movement_speed * dt();
    //radius_inner = 6 + (radius_outer * 0.25);
}
radius_inner = 6 + (radius_outer * 0.25);

/// Do the sucking effect
activation_timer -= dt_sec();
if (activation_timer &lt;= 0)
{
    // Pull in combat actors
    var vortex = id;
    with (CombatActor) 
    {
        pull_residual = 0;
        if (!actor_rigid_set) 
        {
            var weight = scr_stats_getEffectiveStat(id, STAT_BASE_WEIGHT);
            if (weight &gt;= 100) continue;
            
            var dist = point_distance(x, y, vortex.x, vortex.y);
            var zdist = z - vortex.z
            if (dist &lt; vortex.radius_outer and abs(zdist) &lt; (vortex.radius_outer * 0.75)) 
            {
                // Pull in X,Y
                //var ratio = 0.5 + 0.5 * ((vortex.radius_outer - dist) / vortex.radius_outer);
                //ratio /= 1 + (weight / 50);
                var ratio = abs((vortex.radius_outer - dist) - 0) / vortex.radius_outer;
                var pull_dir = point_direction(x, y, vortex.x, vortex.y);
                var pull_amount = (abs(weight - 100) / 100) * ratio * vortex.pull_strength * dt_sec();
                
                // Cap X,Y pull dist to not pull past middle of core
                pull_amount = min(pull_amount, dist);
                pull_residual = pull_amount; // NEW
                scr_collision_move_contact_solid(lengthdir_x(pull_amount, pull_dir),
                                                 lengthdir_y(pull_amount, pull_dir),
                                                 collision_check);
                                      
                // Pull in Z
                str = abs((vortex.radius_outer * 0.75 - dist) / (vortex.radius_outer * 0.75));
                str /= 1 + (weight / 50);
                var pull_amount = (vortex.pull_dist * 0.75 * str) * dt();
                
                // Cap Z pull dist to not pull past middle of core
                pull_amount = min(abs(pull_amount), abs(zdist)) * sign(zdist);
                z -= pull_amount;
                
                
            }
        }
    }
    
    // BULLET
    if (global.zauberBallSuckerBulletPull != 0)
    {
        with (CombatAttackEntity) 
        {
            var dist = point_distance(x, y, vortex.x, vortex.y);
            if (dist &lt; vortex.radius_outer)
            {
                var ratio = (vortex.radius_outer - dist) / vortex.radius_outer;
                var pull_dir = point_direction(x, y, vortex.x, vortex.y);
                var pull_amount = ratio * vortex.pull_strength * dt_sec();
                pull_amount = min(pull_amount * global.zauberBallSuckerBulletPull, dist);
                scr_collision_move_contact_solid(lengthdir_x(pull_amount, pull_dir),
                                                 lengthdir_y(pull_amount, pull_dir),
                                                 collision_check);
            }
        }
    }
    
    // Now repel all actors
    with (CombatActor)
    {
        var mei = id;
        var pds = pull_residual;
        var cp1 = collisionPush;
        with (CombatActor)
        {
            if (id != mei)
            {
                var cp2 = collisionPush;
                if (cp1 != ACTOR_COLLISIONPUSH_NONE &amp;&amp; cp2 != ACTOR_COLLISIONPUSH_NONE &amp;&amp;
                    cp1 != ACTOR_COLLISIONPUSH_IMMOBILE &amp;&amp; scr_entity_zcollision(id, other.id)) 
                {
                    var pushdir = point_direction(mei.x, mei.y, x, y);
                    var pushdist = pds;
                    while (pushdist &gt; 0 &amp;&amp; place_meeting(x, y, mei)) 
                    {
                        var d = min(pushdist, 1);
                        scr_collision_move_contact_solid(lengthdir_x(d, pushdir), lengthdir_y(d, pushdir), collision_check);
                        pushdist -= d;
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
if paused() exit;

if (instance_exists(kid))
{
    kid.x = x;
    kid.y = y;
}


if (movement_distance_remain &lt;= 0) 
{
    kid.stopped = 1;
    scr_entity_setDirSpd(0, 0);
    timeSucking -= dt_sec();
    if (timeSucking &lt;= 0) { instance_destroy(); exit; }
} 
else 
{
    scr_entity_setDirSpd(movement_direction, movement_speed);
    scr_entity_bounceOnCollide(0.75);
    movement_direction = move_dir; // Update in case of wall bounce
    movement_distance_remain -= movement_speed * dt();
    
    radius_inner = 6 + (radius_outer * 0.25);
}

/// Do the sucking effect
activation_timer -= dt_sec();
if (activation_timer &lt;= 0) {
    // Grow in size
    radius_outer = min(radius_outer_max, radius_outer + radius_growth_speed * dt_sec());
    radius_inner = 6 + (radius_outer * 0.25);

    // Pull in combat actors
    var vortex = id;
    
    with (CombatActor) 
    {
        pull_residual = 0;
        if (!actor_rigid_set) 
        {
            var weight = scr_stats_getEffectiveStat(id, STAT_BASE_WEIGHT);
            if (weight &gt;= 100) continue;
            
            var dist = point_distance(x, y, vortex.x, vortex.y);
            var zdist = z - vortex.z
            if (dist &lt; vortex.radius_outer and abs(zdist) &lt; (vortex.radius_outer * 0.75)) 
            {
                // Pull in X,Y
                var ratio = 0.5 + 0.5 * ((vortex.radius_outer - dist) / vortex.radius_outer);
                ratio /= 1 + (weight / 50);
                var pull_dir = point_direction(x, y, vortex.x, vortex.y);
                var pull_amount = (vortex.pull_strength * ratio) * dt();
                
                // Cap X,Y pull dist to not pull past middle of core
                pull_amount = min(pull_amount, dist);
                pull_residual = pull_amount; // NEW
                scr_collision_move_contact_solid(lengthdir_x(pull_amount, pull_dir),
                                                 lengthdir_y(pull_amount, pull_dir),
                                                 collision_check);
                                      
                // Pull in Z
                str = abs((vortex.radius_outer * 0.75 - dist) / (vortex.radius_outer * 0.75));
                str /= 1 + (weight / 50);
                var pull_amount = (vortex.pull_dist * 0.75 * str) * dt();
                
                // Cap Z pull dist to not pull past middle of core
                pull_amount = min(abs(pull_amount), abs(zdist)) * sign(zdist);
                z -= pull_amount;
                
                
            }
        }
    }
    
    // Now repel all actors
    with (CombatActor)
    {
        var mei = id;
        var pds = pull_residual;
        var cp1 = collisionPush;
        with (CombatActor)
        {
            if (id != mei)
            {
                var cp2 = collisionPush;
                if (cp1 != ACTOR_COLLISIONPUSH_NONE &amp;&amp; cp2 != ACTOR_COLLISIONPUSH_NONE &amp;&amp;
                    cp1 != ACTOR_COLLISIONPUSH_IMMOBILE &amp;&amp; scr_entity_zcollision(id, other.id)) 
                {
                    var pushdir = point_direction(mei.x, mei.y, x, y);
                    var pushdist = pds;
                    while (pushdist &gt; 0 &amp;&amp; place_meeting(x, y, mei)) 
                    {
                        var d = min(pushdist, 1);
                        scr_collision_move_contact_solid(lengthdir_x(d, pushdir), lengthdir_y(d, pushdir), collision_check);
                        pushdist -= d;
                    }
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Make visual
kid = instance_create(x, y, oZauberGravity0);
kid.dad = id;
//kid.wellTime = timeSucking;
radius_outer_org = radius_outer;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw
exit;
event_inherited();
//var ratio = 0.5 + 0.5 * ((radius_outer - dist) / radius_outer);

draw_set_color(c_fuchsia);
draw_circle(x, y, radius_outer, 1);
draw_text(x, y, string(timeSucking));
draw_set_color(c_white);
exit;
// Draw inner radius
draw_set_colour(c_black);
draw_ellipse(dx - radius_inner, dy - radius_inner*PERSPECTIVE_FACTOR,
             dx + radius_inner, dy + radius_inner*PERSPECTIVE_FACTOR,
             false);

if (activation_timer &lt;= 0) {   
    // Draw outer radius
    draw_set_alpha(0.5);
    draw_ellipse(dx - radius_outer, dy - radius_outer*PERSPECTIVE_FACTOR,
                 dx + radius_outer, dy + radius_outer*PERSPECTIVE_FACTOR,
                 true);
    draw_set_alpha(1);
}

draw_set_colour(c_white);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
