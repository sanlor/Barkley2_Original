<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s3DWater0</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-110</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Create a point map and multiply
siz = 2560 * 2;
CollisionTriangle(-siz, -siz, 0, siz, -siz, 0, -siz, siz, 0);
CollisionTriangle(siz, -siz, 0, siz, siz, 0, -siz, siz, 0);

tex = sprite_get_texture(s3DWater0, 0);
pointMapWidth = 512 * 2;
pointMapHeight = 512 * 2;
pointMapDivide = 4;
z = 0;//-32;

hue = 0;
thp = 0; ths = 4; thd = random(360); thds = .1 + random(.1);
tvp = 0; tvs = 4; tvd = random(360); tvds = .1 + random(.1);

//2, 4, 8, 16, 32, 64, 128, 256, 512
dv[0] = 1; dv[1] = 2; dv[2] = 4; dv[3] = 8; //dv[3] = 16;
pts[0] = 4; pts[1] = 8 + 1; pts[2] = 24 + 1; pts[3] = 80 + 1; //24 + 1 = 25
for (h = 0; h &lt; pointMapDivide; h += 1)
{
    pointMapSiz[h] = 4 - h;
    pointMapPoints = pts[h];//power(pointMapDivide, h + 1); //4, 16, 64, 256
    pmx = 0;
    pmy = 0;
    pmw = pointMapWidth / (dv[h]); //sqrt(pointMapPoints));
    pmh = pointMapHeight / (dv[h]); //sqrt(pointMapPoints));
    //pmw = pointMapWidth / (sqrt(pointMapPoints) - 1);
    //pmh = pointMapHeight / (sqrt(pointMapPoints) - 1);
    for (i = 0; i &lt; pointMapPoints; i += 1)
    {
        pointMapX[h, i] = pmx;
        pointMapZ[h, i] = 0;
        pointMapY[h, i] = pmy;
        
        pointMapDir[h, i] = random(360);
        pointMapSpd[h, i] = (1 + random(1)) + choose(1, -1);
        pointMapSpd[h, i] /= 3;
        
        pmx += pmw;
        
        if (pmx &gt; pointMapWidth) { pmy += pmh; pmx = 0; }
    }
}

col[0] = c_white;
col[1] = c_ltgray;
col[2] = c_dkgray;
col[3] = c_black;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//
texture_set_repeat(true);
for (h = 0; h &lt; pointMapDivide; h += 1)
{
    draw_set_color(col[h]);
    pointMapPoints = pts[h]; //power(pointMapDivide, h + 1); //4, 16, 32, 64
    for (i = 0; i &lt; pointMapPoints; i += 1)
    {
        siz = pointMapSiz[h];
        pmx = pointMapX[h, i];
        pmy = pointMapY[h, i];
        pointMapZ[h, i] = z + lengthdir_x(2, pointMapDir[h, i]);
        pointMapDir[h, i] += pointMapSpd[h, i];
        pmz = pointMapZ[h, i];
        //d3d_draw_ellipsoid(pmx - siz, pmy - siz, pmz - siz, pmx + siz, pmy + siz, pmz + siz, tex, 1, 1, 8);
    }
}

draw_set_color(c_white);
repeat (1)
{
    
    h = 3;
    pointMapPoints = pts[h];
    for (i = 0; i &lt; pointMapPoints - (dv[h] + 2); i += 1)
    {
        if ((i div 9) != ((i + 1) div 9)) continue;
        pmx = pointMapX[h, i];
        pmy = pointMapY[h, i];
        pmz = pointMapZ[h, i];
        p = dv[h] + 1;
        q = dv[h] + 2;
        d3d_primitive_begin_texture(pr_trianglestrip, tex);
        d3d_vertex_texture(pointMapX[h, i + 0], pointMapY[h, i + 0], pointMapZ[h, i + 0], thp, tvp);
        d3d_vertex_texture(pointMapX[h, i + 1], pointMapY[h, i + 1], pointMapZ[h, i + 1], thp + ths, tvp);
        d3d_vertex_texture(pointMapX[h, i + p], pointMapY[h, i + p], pointMapZ[h, i + p], thp, tvp + tvs);
        d3d_vertex_texture(pointMapX[h, i + q], pointMapY[h, i + q], pointMapZ[h, i + q], thp + ths, tvp + tvs);
        d3d_primitive_end();
    }
}

draw_set_color(c_white);
draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
