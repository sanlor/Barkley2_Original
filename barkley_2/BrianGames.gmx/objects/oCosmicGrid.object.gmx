<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oEffectDraw</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make grid
alpha = 0;
alphaSpeed = 1 / 30;
gridCols = 6 + 1;
gridRows = 6 + 1;
gridSpc = 24; //32;
kill = 0;
mx = gridSpc * ((gridRows - 1) / 2);
my = gridSpc * ((gridCols - 1) / 2);
dx = -(mx);
dy = -(my);
rx = dx;
ry = dy;
for (yy = 0; yy &lt; gridRows; yy += 1)
{
    for (xx = 0; xx &lt; gridCols; xx += 1)
    {
        gpx[xx, yy] = dx;
        gpy[xx, yy] = dy;
        gpxs[xx, yy] = gpx[xx, yy];
        gpys[xx, yy] = gpy[xx, yy];
        if (xx == gridCols - 1 &amp;&amp; yy == gridRows - 1) { gpr[xx, yy] = 0; gpu[xx, yy] = 0; gpl[xx, yy] = 0; gpd[xx, yy] = 0; }
        else if (xx == gridCols - 1) { gpr[xx, yy] = 0; gpu[xx, yy] = 0; gpl[xx, yy] = 0; gpd[xx, yy] = 1; }
        else if (yy == gridRows - 1) { gpr[xx, yy] = 1; gpu[xx, yy] = 0; gpl[xx, yy] = 0; gpd[xx, yy] = 0; }
        else { gpr[xx, yy] = 1; gpu[xx, yy] = 0; gpl[xx, yy] = 0; gpd[xx, yy] = 1; }
        dx += gridSpc;
    }
    dx = rx;
    dy += gridSpc;
}

//Balls
ballRadius = 5;
ballXMin = rx + ballRadius; //global.miniWidth / 2;
ballXMax = rx + (gridSpc * (gridCols - 1)) - ballRadius; //global.miniWidth;
ballYMin = ry + ballRadius; //40;
ballYMax = ry + (gridSpc * (gridRows - 1)) - ballRadius; //global.miniHeight - 17;
balls = 4;
ballBlurs = balls * 5;
ballBlurIndex = 0;
for (i = 0; i &lt; ballBlurs; i += 1) { ballBlurX[i] = -999; ballBlurY[i] = -999; }
for (i = 0; i &lt; balls; i += 1)
{
    ballX[i] = ballXMin + random(ballXMax - ballXMin);
    ballY[i] = ballYMin + random(ballYMax - ballYMin);
    ballDir[i] = random(360);
    ballSpd[i] = (2 + random(1)) / 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Morph based on enemies
global.tx = mouse_x;
global.ty = mouse_y;
global.tObj = id;
with (o_enemy_test)
{
    global.tx = x;
    global.ty = y - 16;
    global.t0 = weight / 2;
    with (global.tObj)
    {
        for (yy = 0; yy &lt; gridRows; yy += 1)
        {
            for (xx = 0; xx &lt; gridCols; xx += 1)
            {
                dis = point_distance(x + gpxs[xx, yy], y + gpys[xx, yy], global.tx, global.ty);
                if (dis &lt; global.t0 * 1.5)
                {
                    dir = point_direction(global.tx, global.ty, x + gpxs[xx, yy], y + gpys[xx, yy]);
                    //gpx[xx, yy] += lengthdir_x(-16, dir) / 20;
                    //gpy[xx, yy] += lengthdir_y(-16, dir) / 20;
                    gpx[xx, yy] -= (gpx[xx, yy] - (gpxs[xx, yy]) + lengthdir_x(global.t0, dir)) / 20;
                    gpy[xx, yy] -= (gpy[xx, yy] - (gpys[xx, yy]) + lengthdir_y(global.t0, dir)) / 20;
                }
                else
                {
                    //do only if unchanged
                    gpx[xx, yy] -= (gpx[xx, yy] - gpxs[xx, yy]) / 20;
                    gpy[xx, yy] -= (gpy[xx, yy] - gpys[xx, yy]) / 20;
                }
            }
        }
    }
}

//BALLS
for (i = 0; i &lt; balls; i += 1)
{
    ballX[i] += lengthdir_x(((ballSpd[i] * 60) / 10) * dt(), ballDir[i]);
    ballY[i] += lengthdir_y(((ballSpd[i] * 60) / 10) * dt(), ballDir[i]);
    //X PLANE
    xx = lengthdir_x(1, ballDir[i]); yy = lengthdir_y(1, ballDir[i]);
    if (ballX[i] &gt; ballXMax) { ballX[i] = ballXMax; ballDir[i] = point_direction(0, 0, -xx, yy); }
    xx = lengthdir_x(1, ballDir[i]); yy = lengthdir_y(1, ballDir[i]);
    if (ballX[i] &lt; ballXMin) { ballX[i] = ballXMin; ballDir[i] = point_direction(0, 0, -xx, yy); }
    //Y PLANE
    xx = lengthdir_x(1, ballDir[i]); yy = lengthdir_y(1, ballDir[i]);
    if (ballY[i] &gt; ballYMax) { ballY[i] = ballYMax; ballDir[i] = point_direction(0, 0, xx, -yy); }
    xx = lengthdir_x(1, ballDir[i]); yy = lengthdir_y(1, ballDir[i]);
    if (ballY[i] &lt; ballYMin) { ballY[i] = ballYMin; ballDir[i] = point_direction(0, 0, xx, -yy); }
}


for (i = 0; i &lt; balls; i += 1)
{
    global.tx = x + ballX[i];
    global.ty = y + ballY[i];
    global.tradius = ballRadius;
    with (o_enemy_test)
    {
        if (collision_circle(global.tx, global.ty, global.tradius, id, 0, 0))
        {
            shake = 4;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw grid
draw_set_color(c_orange);
draw_set_colour_write_enable(1, 1, 1, 0);
dx = x;
dy = y;
for (yy = 0; yy &lt; gridRows; yy += 1)
{
    for (xx = 0; xx &lt; gridCols; xx += 1)
    {
        if (gpr[xx, yy]) draw_line2(dx + gpx[xx, yy], dy + gpy[xx, yy], dx + gpx[xx + 1, yy], dy + gpy[xx + 1, yy]);
        if (gpu[xx, yy]) draw_line2(dx + gpx[xx, yy], dy + gpy[xx, yy], dx + gpx[xx, yy - 1], dy + gpy[xx, yy - 1]);
        if (gpl[xx, yy]) draw_line2(dx + gpx[xx, yy], dy + gpy[xx, yy], dx + gpx[xx - 1, yy], dy + gpy[xx - 1, yy]);
        if (gpd[xx, yy]) draw_line2(dx + gpx[xx, yy], dy + gpy[xx, yy], dx + gpx[xx, yy + 1], dy + gpy[xx, yy + 1]);
    }
}

//Balls
ds = 1;
ap = 0.15 - random(0.1);
for (i = 0; i &lt; ballBlurs; i += 1) 
{ 
    draw_set_alpha(ap * alpha);
    if (ballBlurX[i] != -999)
    {
        draw_set_color(ballBlurColor[i]);
        draw_circle(x + ballBlurX[i], y + ballBlurY[i], ballRadius, 0);
        //draw_line_width(ballBlurX[i], ballBlurY[i], ballBlurX[i + 1], ballBlurY[i + 1], ds);
    }
    //ap *= 0.8;
}
for (i = 0; i &lt; balls; i += 1)
{
    //draw_sprite(sMiniDanmakuShip, 0, ballX[0], ballY[0]);
    cl = c_orange;
    draw_set_alpha((0.5 - random(0.1)) * alpha);
    draw_set_color(cl); //col[i]);
    
    gx = floor((ballX[i] + mx) / gridSpc);
    gy = floor((ballY[i] + my) / gridSpc);
    
    //px0 = (ballX[i] - gpxs[gx, gy]) / gridSpc;
    //py0 = (ballY[i] - gpys[gx, gy]) / gridSpc;
    px0 = (ballX[i] - gpxs[gx, gy]) / gridSpc;
    py0 = (ballY[i] - gpys[gx, gy]) / gridSpc;
    
    
    //dx0 = gpx[gx, gy] + ((gpx[gx + 1, gy] - gpx[gx, gy]) * px0);
    //dy0 = gpy[gx, gy] + ((gpy[gx, gy + 1] - gpy[gx, gy]) * py0);
    
    dx0 = ((gpx[gx + 1, gy] - gpx[gx, gy]) * px0);
    dy0 = ((gpy[gx, gy + 1] - gpy[gx, gy]) * py0);
    
    dx1 = ((gpx[gx + 1, gy + 1] - gpx[gx, gy]) * px0);
    dy1 = ((gpy[gx + 1, gy + 1] - gpy[gx, gy]) * py0);
    
    dx0 = gpx[gx, gy] + mean(dx0, dx1);
    dy0 = gpy[gx, gy] + mean(dy0, dy1);
    
    dx1 = floor(ballX[i]) * ds; 
    dy1 = floor(ballY[i]) * ds;
    //dx0 = floor(ballX[i]) * ds; 
    //dy0 = floor(ballY[i]) * ds;
    //dx1 = floor(ballX[i + 1]) * ds; 
    //dy1 = floor(ballY[i + 1]) * ds;
    //draw_line_width(dx0, dy0, dx1, dy1, ds);
    //dx0 = mean(dx0, dx1);
    //dy0 = mean(dy0, dy1);
    draw_circle(x + dx0, y + dy0, ballRadius, 0);
    
    //dx0 = floor(ballX[i]) * ds; 
    //dy0 = floor(ballY[i]) * ds;
    //draw_set_color(c_red); draw_circle(x + dx0, y + dy0, ballRadius, 0);
    
    ballBlurColor[ballBlurIndex] = cl; //col[i / 2];
    ballBlurX[ballBlurIndex] = dx0;
    ballBlurY[ballBlurIndex] = dy0;
    //ballBlurX[ballBlurIndex + 1] = dx1;
    //ballBlurY[ballBlurIndex + 1] = dy1;
    
    ballBlurIndex += 1;
    if (ballBlurIndex &gt;= ballBlurs) ballBlurIndex -= ballBlurs;
    //if (ballBlurIndex + 1 &gt;= ballBlurs) ballBlurIndex -= ballBlurs;
}
draw_set_alpha(1);
draw_set_colour_write_enable(1, 1, 1, 1);

if (kill == 1) alpha -= alphaSpeed;
else alpha = min(1, alpha + alphaSpeed);
if (alpha &lt;= 0) instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
