<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>oEffectDraw</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Make layers of clouds
clouds = 0;
glow = 1;
glow2 = 1;

prt = 9;
dv = 360 / prt;
cld = clouds;
for (i = clouds; i &lt; cld + prt; i += 1)
{
    event_user(10); //New cloud
    cloudDir[i] = (i * dv) - (dv / 2) + random(dv);
    cloudSpd[i] *= 0.66;
    clouds += 1;
}

prt = 18;
dv = 360 / prt;
cld = clouds;
for (i = clouds; i &lt; cld + prt; i += 1)
{
    event_user(10); //New cloud
    cloudDir[i] = (i * dv) - (dv / 2) + random(dv);
    clouds += 1;
}

prt = 27;
dv = 360 / prt;
cld = clouds;
for (i = clouds; i &lt; cld + prt; i += 1)
{
    event_user(10); //New cloud
    cloudDir[i] = (i * dv) - (dv / 2) + random(dv);
    cloudXScl[i] *= 1.1;
    cloudYScl[i] *= 1.1;
    cloudSpd[i] *= 1.25;//33;
    clouds += 1;
}

prt = 36;
dv = 360 / prt;
cld = clouds;
range = 0;
rangeSpeed = 0;
rangeDecay = 0;
for (i = clouds; i &lt; cld + prt; i += 1)
{
    event_user(10); //New cloud
    cloudDir[i] = (i * dv) - (dv / 2) + random(dv);
    cloudXScl[i] *= 1.2;
    cloudYScl[i] *= 1.2;
    cloudSpd[i] *= 1.5; //1.66
    rangeSpeed = max(rangeSpeed, cloudSpd[i]);
    rangeDecay = min(rangeDecay, cloudSpdSpd[i]);
    clouds += 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Hoopz glow + collision
o_hoopz_hilight.image_alpha = glow / 2;
o_hoopz_hilight.image_color = c_lime;
glow = clamp(glow - (1 / 120), 0, 1);

oEffectBio.flashCol = c_green;
oEffectBio.flashAlp = glow2 / 8;
glow2 = clamp(glow2 - (1 / 60), 0, 1);

//Plume poison
//Only infect if cloud alpha is over certain amount
global.tx = x;
global.ty = y;
global.t0 = range;
with (o_enemy_test)
{
    len = point_distance(global.tx, global.ty, x, y);
    if (bioPlumeKid = -999 &amp;&amp; len &lt; global.t0)
    {
        shake = 4;
        bioPlumeKid = instance_create(x, y - 16, oBioCloud0);
        bioPlumeKid.dad = id;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="20">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///New cloud
cloudActive[i] = 1;

len = random(1);
dir = random(360);
cloudX[i] = lengthdir_x(len, dir);
cloudY[i] = lengthdir_y(len, dir);
cloudXScl[i] = (0.4 + random(0.1));
cloudYScl[i] = (0.4 + random(0.1));
    
cloudAlpDir[i] = 180;//random(360);
cloudAlpDirSpd[i] = (0.66 + random(0.33)) * choose(1, -1);
cloudAlpDirSpd[i] *= 0.33;
cloudAlpDir[i] += cloudAlpDirSpd[i] * floor(random(10));
cloudAlp[i] = lengthdir_y(1, cloudAlpDir[i]);
    
cloudCol[i] = c_green; //merge_color(c_green, c_black, random(0.1));
cloudRot[i] = -5 + random(10);
cloudRotSpd[i] = -1 + random(2);
    
cloudDir[i] = point_direction(cloudX[i], cloudY[i], 0, 0) - 45 + random(90);
cloudSpd[i] = .35 + random(.25); //.4 + .15 - then .45 + .15
cloudSpdSpd[i] = -(cloudSpd[i] / 120);

//MODS
cloudSpd[i] *= 2;
cloudSpdSpd[i] *= 3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw
dx = x;
dy = y;
draw_set_colour_write_enable(1, 1, 1, 0);
for (i = 0; i &lt; clouds; i += 1)
{
    if (cloudActive[i])
    {
        sub = 0;//floor(random(4));
        alp = abs(cloudAlp[i]);
        ap = 1;//0.75 + (alp * .25);
        draw_sprite_ext(sBioRainCloud3, sub, dx + cloudX[i], dy + cloudY[i], cloudXScl[i] * ap, cloudYScl[i] * ap, cloudRot[i], cloudCol[i], alp * .66);
    
        cloudX[i] += lengthdir_x(cloudSpd[i], cloudDir[i]);
        cloudY[i] += lengthdir_y(cloudSpd[i], cloudDir[i]);
        cloudRot[i] += cloudRotSpd[i];
        
        cloudSpd[i] = clamp(cloudSpd[i] + cloudSpdSpd[i], 0, 10);
        cloudAlpDir[i] += cloudAlpDirSpd[i];
        cloudAlp[i] = lengthdir_y(1, cloudAlpDir[i]);
        if (cloudAlpDir[i] &gt;= 360 || cloudAlpDir[i] &lt;= 0) { cloudActive[i] = 0; }
    }
}
draw_set_colour_write_enable(1, 1, 1, 1);

//Collision mask
range += rangeSpeed;
rangeSpeed = clamp(rangeSpeed + rangeDecay, 0, 10);
//draw_circle(dx, dy, range, 1);

//Destroy when no clouds exist
cld = 0;
for (i = 0; i &lt; clouds; i += 1) { if (cloudActive[i]) { cld = 1; break; } }
if (cld == 0) instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
