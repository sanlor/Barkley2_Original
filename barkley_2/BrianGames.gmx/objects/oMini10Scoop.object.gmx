<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2600000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Create
cRed = make_color_rgb(255 - 16, 16, 16);
cYellow = make_color_rgb(255 - 16, 255 - 16, 16);
cBlue = make_color_rgb(16, 16, 255 - 16);

sur = -1;

event_user(0);

paperTitle = "Good Brew Bi-Weekly";
paperTitle = string_upper(paperTitle);

paperX = global.miniWidth / 2;
paperY = global.miniHeight / 2;
paperY += 2 * global.miniScale;

scoopNam[0] = "Vanilla";
scoopNam[1] = "Chocolate";
scoopNam[2] = "Strawberry";
scoopNam[3] = "Banana";
scoopNam[4] = "Pistachio";
scoopNam[5] = "Rocky Road";
for (i = 0; i &lt; 6; i += 1) scoopNam[i] = string_upper(scoopNam[i]);
scoopTitl[0] = "Vanilla Year's Top Flavor";
scoopTitl[1] = "Chocolate Sales Plummet";
scoopTitl[2] = "Strawberry Voted \#1 Cream";
scoopTitl[3] = "Banana Crashes, Investors Flee";
scoopTitl[4] = "Pistachio Named In Terror Plot";
scoopTitl[5] = "Rocky Road Sweeps Awards";
scoopMax = 6;
scoopDo = floor(random(6));
//scoopName = scoopNam[];
scoopTitle = string_upper(scoopTitl[scoopDo]);
scoopSelect = floor(random(6));

boxTex[0] = "?";
boxTex[1] = "?!?";
boxTex[2] = "!!!";
boxTex[3] = "!";
boxTex[4] = ";^)";
boxTex[5] = "...";
boxTex[6] = "BUY";
boxTex[7] = "YES";
boxTex[8] = "NO";
boxText = boxTex[floor(random(9))];
//paperX = 0; paperY = 0;

textWrg[0] = "GET A CLUE!";
textWrg[1] = "TRY AGAIN!";
textWrg[2] = "NOT A CHANCE!";

textRgt[0] = "GOOD ONE!";
textRgt[1] = "RIGHT ON!";
textRgt[2] = "YOU'RE THE BEST!";

textWrong = textWrg[floor(random(3))];
textRight = textRgt[floor(random(3))];
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (surface_exists(sur)) surface_free(sur);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///surface
//240, 200
if (surface_exists(sur) == 0)
{
    sur = surface_create(240, 200);
    surface_set_target(sur);
    draw_sprite(sMiniScoop, 0, 120, 100);
    draw_set_color(c_black);
    draw_set_font(CourierNew12);
    draw_set_halign(1);
    
    draw_text_ext(120, 6, paperTitle, -1, 2000);
    draw_set_font(CourierNew12b);
    draw_text_ext(120, 33, scoopTitle, -1, 200);
    draw_set_font(CourierNew24);
    draw_set_valign(1);
    draw_text_ext(120, 100, boxText, -1, 200);
    draw_set_valign(0);
    draw_set_halign(0);
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///keys
if (MiniKeyPress("cancel")) { Minigame("stop"); instance_destroy(); }

if (state == 0)
{
    if (MiniKeyPress("left"))
    {
        scoopSelect -= 1;
        if (scoopSelect &lt; 0) scoopSelect = scoopMax - 1;
    }
    if (MiniKeyPress("right"))
    {
        scoopSelect += 1;
        if (scoopSelect &gt;= scoopMax) scoopSelect = 0;
    }
    
    if (MiniKeyPress("action"))
    {
        state = 1;
    }
}
else if (state == 1)
{
    paperScl += (((0.01 + (paperScl / 100)) * 60) / 10) * dt();
    paperScl = min(1, paperScl);
    paperRot += ((paperRotSpd * 60) / 10) * dt();
    if (paperScl == 1 &amp;&amp; abs(direction_difference(paperRot, paperRotDes)) &lt;= abs(paperRotSpd)) 
    {
        if (scoopSelect == scoopDo) { audio_play_sound(mMiniRight, 10, 0); }
        else { audio_play_sound(mMiniWrong, 10, 0); }
        state = 2;
        paperRot = paperRotDes;
    }
}
else if (state == 2)
{
    if (MiniKeyPress("action"))
    {
        //room_goto(rMiniSelect);
        instance_destroy();
        instance_create(0, 0, oMini10Select);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Reset game
state = 0;
paperScl = 0;
paperRot = 0;
paperRotSpd = (10 + random(2)) * choose(1, -1);
paperRotDes = - 1 + random(2);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw
ds = paperScl * global.miniScale;
//draw_sprite_ext(sMiniScoop, 0, paperX * global.miniScale, paperY * global.miniScale, ds, ds, paperRot, c_white, 1);
if (surface_exists(sur))
{
    dx = global.miniX + (paperX * global.miniScale);
    dy = global.miniY + (paperY * global.miniScale);
    dx += lengthdir_x(120 * ds, 180 + paperRot);
    dy += lengthdir_y(120 * ds, 180 + paperRot);
    dx += lengthdir_x(100 * ds, 90 + paperRot);
    dy += lengthdir_y(100 * ds, 90 + paperRot);
    draw_surface_ext(sur, dx, dy, ds, ds, paperRot, c_white, 1);
}

//Blue border
draw_set_color(cBlue);
draw_rectangle(global.miniX, global.miniY, global.miniX + global.miniWidthS, global.miniY + (17 * global.miniScale), 0);

if (state == 0)
{
    draw_set_color(c_white);
    draw_set_font(CourierNew12);
    draw_set_halign(1);
    draw_text_transformed(global.miniX + (global.miniWidthS / 2), 0, "GUESS THE SCOOP", global.miniScale, global.miniScale, 0);
    draw_set_font(CourierNew24b);
    draw_set_valign(1);
    draw_set_color(cRed);
    draw_text_transformed(global.miniX + (global.miniWidthS / 2), global.miniY + (global.miniHeightS / 2), scoopNam[scoopSelect], global.miniScale, global.miniScale, 0);
    draw_set_color(c_white);
    draw_text_transformed(global.miniX + (global.miniWidthS / 2) - (112 * global.miniScale), global.miniY + (global.miniHeightS / 2), "&lt;", global.miniScale, global.miniScale, 0);
    draw_text_transformed(global.miniX + (global.miniWidthS / 2) + (112 * global.miniScale), global.miniY + (global.miniHeightS / 2), "&gt;", global.miniScale, global.miniScale, 0);
    draw_set_valign(0);
    draw_set_halign(0);
}



if (state == 2)
{
    draw_set_color(c_white);
    draw_set_font(CourierNew12);
    draw_set_halign(1);
    if (scoopSelect == scoopDo) draw_text_transformed(global.miniX + (global.miniWidthS / 2), global.miniY, textRight, global.miniScale, global.miniScale, 0);
    else draw_text_transformed(global.miniX + (global.miniWidthS / 2), global.miniY, textWrong, global.miniScale, global.miniScale, 0);
    draw_set_halign(0);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>120,100</point>
    <point>120,120</point>
  </PhysicsShapePoints>
</object>
